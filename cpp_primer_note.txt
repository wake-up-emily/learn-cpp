c++细节
- 第二章 变量和基本类型
	- 基本内置类型
		- 算数类型
			- 整型
				- char 8位
				- int 16位
				- long 32位
				- long long 64位
			- 浮点型
				- float 6位有效数字
				- double 10位有效数字
			- 使用建议
				- int 整数运算
				- 确保不可能为负的值 用无符号
				- 算术表达式不要使用char or bool 不同机器char不一定是有符号或无符号 运算容易出问题
				- double 浮点运算
		- 类型转换
			- 带符号 无符号
				- 注意不要混用带符号型和无符号型
				- 不要在循环判定中使用无符号类型 尤其是 --i 这种操作 无符号类型
		- 字面值常量
			- 整数和浮点型字面值
				- 8进制 0开头
				- 16进制 0x开头
			- 字符串型字面值
				- char 'a'
				- string "a" 其实是char数组后加一个'\0'结尾符 'a'+'\0'
			- 转义序列 
				- 当做一个字符来使用
					- 换行 \n
					- 制表 \t
					- 回车 \r
					- 反斜线 \\
				- 泛化转义序列
					- 8进制 最多\后能读三位 "\1234" // "s4"
					- 16进制 \x 后能读四位
			- 布尔字面值 true false
			- 指针字面值 nullptr
	- 变量
		- 介绍
			变量提供一个具名的 供程序操作的存储空间 
			C++中每个变量都有其数据类型 
			数据类型决定变量所占内存空间的大小和布局方式 值的范围 变量参与的运算等
			变量value 对象object 一般可以互换使用 
			（对象：一块能存数据并具有某种类型的内存空间）
		- 变量定义 
			- 初始值
				- = 用于初始化 也用于赋值 初始化和赋值在C++是两种不同的操作
					初始化：创建变量时给一个初始值
					赋值：把已有对象的当前值擦除 给一个新值
			- 列表初始化 {} 
				- 尤其编译期规避类型转换时信息丢失的风险
			- 默认初始化
				- string 一个空串 '\0'
				- int 0
		- 变量声明和定义的关系
			- extern 
			- 变量只能定义一次 但可以多次声明
		- 标识符
			- c++关键字 73个 操作符替代名 11个
			- 变量命名规范
				- 体现含义
				- 小写
				- 自定义类大写字母开头
		- 名字的作用域 {}
			- 全局作用域 main
				- 全局变量int 初始值为0 main函数体内部int不被初始化是未定义的行为 
				尝试拷贝或输出时会输出一个未定义的奇异值（1）//139497509
			- 建议第一次使用变量时再定义它
	- 复合类型
		- 引用 &（左值引用）
			- T val{};
			- T &r = val;
			- 引用必须初始化 和具有初始值的对象绑定在一起
			- 引用即别名 （注：美化的指针 看到的是绑定对象的地址和大小）
		- 指针 *
			- Nullptr
			- 指针和引用的区别
				- 指针是对象 允许拷贝和赋值 可多次赋值 可无初始值
				- 引用不是对象 只能绑定一次 必须有初始值
			- 获取对象的地址
				- T val;
				- T *p = &val;
			- 指针值（地址）的四种状态：
				- 指向一个对象
				- 指向紧邻对象所占空间的下一个位置
				- 空指针
				- 无效指针 试图拷贝或访问无效指针都会引发错误 编译器不会检查此类错误 未定义的行为
			- 利用指针访问对象
				- 解引用 *p （注：指针是对象 *其实是操作符重载）
			- 空指针
				- T *p = nullptr || T *p = 0 （注：*p = 0是解引用对象的值并赋值为0）
				- 建议初始化所有指针 空指针操作是编译器能检查的错误 比无效指针的未定义行为好多了
			- 赋值和指针
				- 给指针赋值 相当于 存放一个新的地址 指向新的对象
				- 赋值改变的永远是左值
			- 其他指针操作
				- if (p) 任何非空指针都会返回true
				- == 3种可能：
					- 都为空
					- 都指向同一个对象
					- 都指向同一个对象的下一地址
			- void* 指针
				- 可用于存放任意类型对象的地址
				- 但可以做的操作有限 只有内存地址 不知道解析方式 只能进行指针比较和作为函数的输入输出 不能访问对象
		- 理解复合类型的声明
			- 定义多个变量
				- T v{}, *p = &v;
				- T* p1,p2; 这种写法合法 但看上去会误以为本条定义中的所有变量都是T型指针 其实p2是T型对象 不是指针
				- T* p1;
				- T* p2; 这样分开写就比较清晰
			- 指向指针的
				- 指针 ** ***
				- 引用 不仅改变指针所指的对象 也改变指针本身 （因为指向指针的引用就代表了指针）
		- const
			- 介绍
				初始化变量后不允许其赋值（但不影响它作为右值赋值给别人 again: 赋值改变的永远是左值）
			- 默认状态下 const对象仅在文件内有效
				- 编译器全文替换变量名的值为初始值
				- 多个文件使用同一个const对象可以使用extern暴露变量
			- 常量引用
				- 常量引用可以指向常量对象和非常量对象（但它们以为自己指向了常量对象 所以自觉地不去改值）
				- 常量对象只能有常量引用 不能有非常量引用
				- 非常量对象可以有常量引用 也可以有非常量引用 常量引用不能用于赋值 非常量引用可以 或者直接给对象赋值也可以
				- 常量对象和常量引用使用时不能作为左值赋值 只能作为右值赋值
			- 常量指针
				- 类似常量引用
				- 但是回顾引用和指针的区别：引用只能绑定到一个具有初始值的对象 指针是一个对象 可以多次绑定
					如果要使常量指针只能一次绑定 在变量名前还需加一个const
					- const int *p = 42; const int *const p = 42; 新加的const保证p永远指向42
					- const int *const p3 = &v p3永远指向变量v，p3是常量指针 无法通过p3修改v的值
				- 常量指针不能被赋值 初始化如果没有值就只能一直没有值
			- 顶层const/底层const
				- 对常量指针来说 不能改值和不能指向别的对象是两件事
					- 顶层const 指针是常量 （离指针近的const） 不指向别的对象（但可以改值）
					- 底层const 对象是常量 （离指针远的const 数据类型） 不能改值（但可以指向别的对象）
					- 顶层+底层const 不指向别的对象 且 不能改值
						- const int *const p = 42; 右边顶层（p是常量），左边底层（对象是常量）
				- 拷贝操作 
					- 顶层const虽然支持改值 但拷贝操作不改值 对其没有影响 
					- 底层const要求左值和右值有相同的底层const资格 或右值可转换成左值的数据类型
		    - constexpr 
		    	- 常量表达式 值不会改变且在编译过程中就能得到值的表达式
		    	- constexpr int *p 等价于 int *const p 把p置为顶层const
		- 处理类型
			- 目的
				- 类型名难记 复杂
				- 类型的真正用途和含义 （别说多人经手的代码了 一个人写的也可能忘）
			- 类型别名 typedef/using
				- 使用
					- typedef double wages;
					- using wages = double;
				- 指针 常量和 类型别名
					- 回顾顶层const的语法：定义时在变量名前加一个const
					- 当有类型别名时
						- 类型别名含const 底层const
						- 类型别名不含const 非底层const
							定义时在类型别名前加一个const
					- using int_ptr = int*;
					    int i(42), i2(1024);
					    const int_ptr p = &i;
					    // p = &i2; //底层const可以指向别的对象 这里不可
					    *p = 1024; //顶层const可以改值 这里可
					    cout << *p << endl; //1024
				    - using int_ptr = const int*;
					    int i(42), i2(1024);
					    int_ptr p = &i;
					    p = &i2; //底层const可以指向别的对象 这里可
					    // *p = 1024; //顶层const可以改值 这里不可
					    cout << *p << endl; //1024
			- 类型说明符 auto
				- 目的
					- 声明变量时清楚地知道类型这很难（虽然侯捷老师说c++程序员就是应该了然于胸）
					- 注：本书大量案例是auto和迭代器类型的配合使用
				- 一条语句只有一个数据类型
				- 忽略顶层const
				- 实际计算变量的初始值后推断类型
			- 类型指示符 decltype
				- 目的
					- 希望从表达式推断变量类型 但不希望用该表达式的值初始化变量
						编译器会分析表达式推导类型 但不进行实际运算
				- 保留顶层const
				- (()) 结果是引用类型
				- (*p) 解引用得到引用类型 引用类型必须初始化
					- decltype(*p) c; //不可
- 第三章 字符串 向量 和数组
	- 命名空间 using声明
		- using namespace::name;
		- 每个名字都需要独立的using声明
		- 头文件不应包含using声明
	- 标准库类型 string
		- 定义和初始化string对象
			- 操作
				- string s;
				- string s2(s1);
				- string s2 = s1;
				- string s("value");
				- string s = "value";
				- string s(n,'char');			连续n个字符c组成的字符串
				- string s = (n,'char'); 		其实是先生成tmp临时变量 再赋值给s
		- string对象上的操作
			- 操作
				- os << s;						写	
				- is >> s;						读	读未知数量的string对象 通常while循环
				- getline(is,s);				读一整行 通常while循环
				- s.empty();					bool
				- s.size();						string::size_type 一个无符号值 
					- 不要混用size_type和int 强转类型时负数int会转成一个很大的正数 因此无符号数总是小于一个负数
					- size_type和size_t的区别
						- size_t is defined as the type used for the size of an object and is platform dependent.
						- container::size_type is the type that is used for the number of elements in the container and is container dependent.
						- All std containers use size_t as the size_type, but each independent library vendor chooses a type that it finds appropriate for its container.
						- If you look at qt, you'll find that the size_type of Qt containers is version dependent. In Qt3 it was unsigned int and in Qt4 it was changed to int.
				- s[n];							
					- 返回s字符串第n个位置的引用 位置从0开始计数
					- string::size_type n 实际使用时需要检查n是否<s.size()
				- s1 + s2;
						string p2 = "hello " + "world " + s 就不行						
				- s1 = s2;
				- s1 == s2;						长度相同 包含字符也相同
				- s1 != s2;
				- < <= > >= 					字典序 大小写敏感
		- 处理string对象中的字符
			- 操作
				- isalnum(c);					char是 	字母或数字	为真
				- isslpha(c);					char是 	字母 		为真
				- isdigit(c);					char是 	数字	 		为真
				- isxdigit(c);					char是	16进制数字	为真
				- ispunct(c);					char是 	标点			为真
				- isspace(c);					char是	空白			为真
				- isprint(c);					char是 	可打印字符 	为真
				- isgragh(c);					不是空格但可以打印		为真
				- islower(c);
				- isupper(c);
				- tolower(c);
				- toupper(c);
			- 处理每个字符 使用for循环
				- for (declaration : expression)
					statement
					- 逻辑运算符 &&
			- 处理部分字符
				- []
	- 标准库类型 vector
		- 介绍
			- 标准库容器之一 使用时需要声明
				#include <vector>
				using std::vector;
			- vector是模板而非类型 使用时需要提供额外信息数据类型T
		- 定义和初始化vector对象
			- 操作
				- vector<T> v;					v是一个空vector容器 按照T类型元素初始化 常用 先创建空容器再逐一添加元素
				- vector<T> v2(v1);				
				- vector<T> v2 = v1;
				- vector<T> v(n,val);
				- vector<T> v(n);				n个T类型的元素 值为T类型元素初始值
				- vector<T> v{a,b,c...};
				- vector<T> v = {a,b,c...};
		- 向vector对象中添加元素
			- 操作
				- v.empty();
				- v.size();
				- v.push_back(val);				常用于for循环
				- v[n]							返回容器第n个位置上元素的引用 注意事项同string s[n]
				- v1 = v2;
				- v1 = {a,b,c...};
				- v1 == v2;						容器所含元素数量相同 每个位置的元素相同（使用数据类型定义的比较方法来比较）
				- v1 != v2;
				- < <= > >= 					字典序
		- 其他vector操作
			- iterator 
				- v.begin(), v.end()
				- ->
				- begin + (end - begin)/2 or (begin + end)/2
	- 迭代器介绍
		- 使用迭代器
			- 操作
				- *iter;							解引用 返回迭代器所指元素的引用
				- iter->mem;						
					- 相当于 (*iter).mem; 
					- 解引用不加括号时试图访问迭代器对象的mem成员再解引用 引入新符号避免歧义
				- ++iter;							返回容器的下一个元素
				- --iter;							返回容器的上一个元素
				- iter1 == iter2;
					- 回顾指针 == 的3种可能：
						- 都为空
						- 都指向同一个对象
						- 都指向同一个对象的下一地址					
					- 两个迭代器相等的条件：
						- 都指向同一个对象
						- 都指向同一个对象的下一地址	
				- iter1 != iter2;
			- 移动迭代器
				- for (auto it=s.begin();it!=s.end();++it) {
					 *it = toupper(*it); 
					 }
				- for (auto it=s.cbegin();it!=s.cend();++it) {
					 cout << *it; 
					 } 
				 cout << endl;
			 - 迭代器类型
			 	- C<T>::iterator
			 	- C<T>::const_iterator 		类似底层const 可以读取不能改值
		 	- begin和end运算符
		 		- 如果对象是const的 则返回const_iterator
		 		- 如果对象不是		  返回iterator
	 		- 结合解引用和成员访问操作
	 			- 解引用最好加括号
			- 某些对vector对象的操作会使迭代器失效
				- 使用了迭代器的循环体 不要向容器添加元素
		- 迭代器运算
			- 操作
				- iter + n 					从原迭代器的位置向前推进n个位置 得到一个新的迭代器
				- iter - n 					从原迭代器的位置向后回退n个位置 得到一个新的迭代器
				- iter += n
				- iter -= n
				- iter1 - iter2 			得到距离值
				- < <= > >= 				同一个容器中迭代器位置的比较
	- 内置数组
		- 定义和初始化内置数组
			- 操作
				- int a[] = {0,1,2};
				- int a[3] = {0,1};
			- 不允许拷贝和赋值
			- init
				- int (*p)[10] = &arr
				- int (&r)[10] = arr
		- 访问数组元素
			- [n] 							size_t类型 和size_type一样需下标范围检查
		- 指针和数组
			- 指针也是迭代器
				- 指针默认指向数组/容器的首元素
			- 标准库函数begin(arr), end(arr) 非成员函数
			- 指针运算
				- 支持所有迭代器运算
				- 指针相减 得到的值为ptrdiff_t的标准库类型 类似有符号的size_t
			- 下标和指针
				- 内置数组的下标运算支持负值
		- c风格字符串
	- 多维数组
		- 数组的数组 不是真正的多维数组
		- 初始化
			- int ia[row][col] 二维数组
			- int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11} or int ia[3][4] = {{0,1,2,3},{4,5,6,7},{8,9,10,11}}
		- 下标引用
			- int (*p)[col] = ia 即 int (*p)[col] = &ia[0] 回顾：指针默认指向数组的首元素地址
			- int (&r)[col] = ia[1]
		- for
			- 除了最内层循环 其他所有循环的控制变量都要求是引用型
				否则外层循环中row被解释为int * 即数组首元素的指针 内层循环并不合法
		- 类型别名简化多维数组的指针
- 第四章 表达式
	- ++
		- 后++ *p++在循环中是高效的写法
	- 逻辑运算符
	- 位运算符 & | ^(异或 11=0 其余为1)
	- 左移右移
	- sizeof
	- 类型转换
		- 强转
			- static_cast
			- const_cast
			- （reinterpret_cast）不建议使用 太容易出错了
	- 运算符优先级
- 第五章 语句
	- {} 作用域
	- 条件语句
		- if
		- case
			- char cin.get() 和 cin >> c 有区别 前者统计不到\t \n 空格之类的
			- 多个case同一出口可以合并
			- case标签必须是常量表达式
	- 循环语句
		- while
		- do while
		- for
	- 跳转语句
		- break
		- continue
	- try catch
		- 标准库定义的标准异常
	- throw
- 第六章 函数
	- 基础
		- 形参/实参
		- 局部对象
			- 局部静态对象
		- 函数声明
			- 头文件&源文件放什么
	- 参数传递
		- 值传递 形参和实参是分开独立的对象 即离开函数作用域后实参没有影响
		- 引用传递 形参通过调用实参的引用达到修改实参的目的 或通过增加引用型参数的方式 达到返回多于一个值的效果 本质还是写
		- 常值引用 函数无意对实参进行修改 在实参值较大的情况下 避免拷贝原值 更快地调用实参 达到读的目的
		- 数组形参
			- 传指针
				- 数组都是以指针的形式传递的 只有地址 不知道数组的具体大小
				- void print(const int arr[]) 等价于 void print(const int arr[10]) 实参都是 const int * 类型的
			- 传引用
			- 传多维数组
				- int (*matrix)[10] 代表一个指针指向int[10]的数组
				- int *matrix[10] 	代表一个数组 包含10个int型的元素
				- int matrix[][10] 	代表一个数组 包含10个int型的元素
		- main 命令行debug argc argv参数
		- 可变形参
		- 省略符形参
	- 返回类型和return语句
		- 返回语句可以用三元运算符
		- 不要返回局部对象的引用或指针
		- 引用返回左值
		- 递归
		- 返回数组指针
			- using
			- 尾置返回类型
			- decltype
	-函数重载
		- const
		- 函数匹配
		- 重载确定
	- 特殊用途语言特性
		- 默认实参
			- 放最后 一个参数带默认实参 其后的所有参数都必须带默认实参
		- 内联函数 inline
			- 你向编译器请求内联 编译器会看情况看决定是否内联
			- 适用于优化规模较小（75行内） 流程直接 频繁调用的函数 比如函数还调用了标准库的函数 那显然就不算是可以内联了
		- constexpr
			- 隐式指定为inline函数
			- 不一定返回常量表达式 当不是的时候 编译不会通过
		- 预处理器
			- assert
			- __FILE__
			- __LINE__
			- __TIME__
			- __DATE__ //现代编译器其实有cover这部分
	- 函数匹配
		- 候选函数
		- 可行函数
			- 二义性调用
			- 实参类型转换
				- 类型提升
				- 算数类型转换
				- const转换
				- 类类型转换
	- 函数指针
		- using
		- 尾置返回类型
		- decltype
- 第七章 类
	- 定义抽象数据类型
		- 成员函数
			- this
			- const 成员函数
			- 类作用域和成员函数
			- 在类外定义成员函数
		- 非成员函数
		- 构造函数
			- 默认构造函数
			- 初始值
			- 在类外定义构造函数
		- 拷贝 赋值和析构
	- 访问控制与封装
		- public/private
		- class/struct
		- 友元函数
	- 类的其它特性
		- inline
		- 重载
		- 可变数据成员 mutable
			- 即使一个声称是const的函数也可以修改可变数据成员的值
		- const成员函数返回*this是一个常量引用
		- 基于const的重载
			- const object只会调用const函数
			- non-const object只会调用non-const函数
			- 为了提供均能满足的两个函数 建议把实际工作的代码封装成私有函数 再去调用私有函数来使用
		- 类类型
			- 同样成员的类 类名不同则类类型不同
		- 友元
			- 类友元
			- 成员函数友元
				- 看上去比较复杂
	- 类的作用域
		- 名字查找
		- 类型名
	- 构造函数
		- 初始值
		- 初始化的顺序
		- 默认实参与构造函数
			- 如果一个构造函数为所有参数都提供了默认实参 那它实际上也定义了默认构造函数
			- 注意二义性调用
		- 委托构造函数
		- 默认构造函数的作用
			- 如果定义了其他构造函数 编译器就不会提供默认无参构造函数 最好自己写一个
			- 使用时注意 声明一个对象和声明一个无参函数的区别 （）
		- 隐式的类类型转换
			- 只出现在拷贝构造 与拷贝赋值没有关系
			- 只允许一步类类型转换
			- 类型转换不总是有效
			- explicit 防止构造函数隐式类类型转换
			- static_cast<type> 如果实在需要 可以显式转型
		- 聚合类
			- 所有成员public 无任何构造函数 无类内初始值 无基类 无virtual函数
		- 字面值常量类
			- constexpr
	- 类的静态成员
		- 声明
		- 使用
			- ::
			- 成员函数可直接调用
		- 类内初始化
			- const/ constexpr
- 第八章 IO库
	- IO类
		- iostream
		- fstream
		- sstream 
			- ifstream和istringstream都继承自itream 也就是cin怎么用这俩就能怎么用
		- IO对象无拷贝或赋值
			- 一般传引用 因为读写一个IO对象会改变其状态 传递和返回的引用不能是const
		- 状态
			- in.eof()
			- in.bad()
			- in.fail()
			- ... 一般while (in)检测就代表这些重要的flag值没有设为true
			- 循环中要先重置in.clear() 每一次循环复位in的标志状态
			- endl 表示换行并刷新缓冲区
			- cout << unitbuf 表示任何输出都立即刷新 无缓冲 cout << nonunitbuf 表示回到默认的带缓冲输出
			- 如果程序崩溃 缓冲区不会刷新
			- 任何读取操作都会先刷新关联的输出流 所以交互式系统一般会关联输入流和输出流 使读取操作前打印出用户的输入
	- 文件输入输出
		- 使用
			- ifstream fstrm(file); 关联到输入文件
			- ifstream fstrm(file,mode); 关联到输入文件并选择mode in or out
			- fstrm.open();
			- fstrm.close(); 当一个fstrm离开作用域时 .close()会自动调用
			- fstrm.is_open();
		- 文件模式
			- out 只可以对ofstream和fstream选择out模式 以out模式打开会丢失已有数据
			- in  只可以对ifstream和fstream选择in模式
			- app 以app模式打开不会丢失已有数据
			- trunc 只有当out也被设定时才可以用trunc模式 默认情况下 out模式下没有指定trunc 也会截断文件
		- string流
			- 使用
				- sstream strm; 未绑定string对象的strm 配合strm.str(s)使用
				- sstream strm(s); 绑定strm与string
				- strm.str() 返回strm所保存的str的拷贝 eg. cout << strm.str() << endl;
				- strm.str(s) 将s拷贝到strm中 返回void
			- istringstream
			- ostringstream
- 第九章 序列式容器
	- 概述
		- 所有容器都有不同程度的性能折中
			- 添加或删除元素的代价
			- 非顺序访问容器元素的代价
		- 序列式容器
			- vector 连续空间 可扩展 快速随机访问元素 在尾部之外的位子插入元素或删除元素可能很慢
			- deque 双端队列 两端可进出 双向可扩充 在头尾插入/删除元素很快 
			- list 双向链表 只支持双向顺序访问 在链表任何位置插入/删除元素都很快
			- forward_list 单向链表 只支持单向顺序访问 在链表任何位置插入/删除元素都很快
			- array 创建时分配固定大小的连续空间 可快速随机访问 不能添加或删除元素
			- string 与vector相似 但只存char 连续空间 可扩展 快速随机访问元素 在尾部之外的位子插入元素或删除元素可能很慢
		— 序列式容器选择
			- 通常 使用vector是最好的序列式容器选择 除非你有更好的选项
			- 选择容器的原则
				- 能不能选vector?
				- 程序有很多小的元素 且空间的额外开销很重要 不要选list or forward_list
				- 要求在容器的中间插入/删除元素 选list/forward_list
				- 要求随机访问元素 选vector or deque
				- 头尾要求插入/删除 但中间不需要插入/删除 选deque
				- 输入时要求向中间插入元素 使用时需要随机访问：
					- 能不能先放进去再排序？
					- 输入阶段用list 输入完成后存到vector
				- 其他情况最好看性能测试的结果
	- 容器库概览
		- 容器操作层次
			- 所有容器都提供的操作
			- 按迭代器分类容器提供的操作
			- 部分容器独有的操作
		- 容器操作类型
			- 类型别名
				- iterator
				- const_iterator
				- size_type 无符号整数类型 足以保存该容器可提供的最大容器大小
				- difference_type 带符号整数类型 足以保存两个迭代器之间的距离
				- value_type 元素类型
				- reference 左值类型 等于 value_type&
				- const_reference
			- 构造函数（6种）
				- C c; 默认构造
				- C c1(c2); 容器拷贝构造
				- C c1 = c2; 拷贝赋值
				- C c{a,b,c...}; 花括号拷贝构造
				- C c = {a,b,c...}; 花括号拷贝赋值
				- C c(b,e); 迭代器拷贝构造

				序列式容器+2种：
				- C seq(n); 包含n个元素，元素值为初始值
				- C seq(n,t); 包含n个元素，元素值为t
			- swap
				- a.swap(b);
				- swap(a,b); 通常比a.swap(b)快得多
			- 大小
				- c.size(); forward_list不支持
				- c.empty();
				- c.max_size();
			- 关系运算符
				- ==, !=
				- < <= > >=
			- 获取迭代器
				- c.begin(), c.end()
				- c.cbegin(), c.cend()
			- 反向容器
				- c.rbegin(), c.rend()
				- c.crbegin(), c.crend()
		- 迭代器
			- forward_list 不支持 --
			- 迭代器范围
				- 左闭右开区间 右指向尾元素之后的位置 [begin, end)
				- 迭代器范围的形成：
					- begin end在同一个容器或end指向容器最后一个元素之后的位置
					- end >= begin
				- begin = end时 由于左闭右开 也就是范围为空
				- begin != end时 范围至少包含一个元素 也就是begin
				- 可以递增begin若干次 使begin = end
		- 容器类型成员
			- 使用类型别名
		- begin和end成员
			- cbegin() 和 cend()配合 auto使用 eg. auto it = c.cbegin(); 其实auto就是const_iterator类型
			- 不需要写访问时应使用cbegin()和cend()
		- 容器定义和初始化
			- 不同类型的容器不能使用拷贝构造和拷贝赋值 但可以使用迭代器拷贝构造 或者c1.assign.(c2_cb,c2_ce)
			- array容器
				- array容器和内置数组的区别
					- 形式
						- int arr[] = ... 这是内置数组 不是array容器
						- array<type,n> 这是array容器 数组类型和大小一起构成了array容器
					- 拷贝
						- 内置数组不支持拷贝构造或拷贝赋值
						- array容器支持
		- 赋值和swap
			- 使用assign(仅序列式容器)
				- 允许从一个不同但相容的类型赋值 或从容器的一个子序列赋值
			- 使用swap
				- 很快 元素本身未交换 交换的是两个容器的内部数据结构
				- 除array外 swap不对任何元素进行拷贝 删除或插入操作 O(1)
				- 元素在swap过程中没有移动 意味着指向元素的迭代器 引用和指针不会失效
				- arr.swap()真正交换元素 O(n)
		- 关系运算符
			- 两个容器比大小：
				- 使用元素定义的关系运算符比大小
	- 序列式容器操作
		- 添加 除forward_list外
			- c.push_back(); 元素拷贝 不影响到提供值的原始对象
			- c.emplace_back(); 构造而非拷贝
			- c.push_front(); vector和string不支持
			- c.insert(p,n,t); 
				- 在迭代器p指向的元素之前插入n个值为t的元素 返回新添加的第一个元素的迭代器 
				- 当p指向c.begin()并开始循环调用时相当于push_front() 
				- 向一个vector string或deque插入元素会使所有指向容器的迭代器 引用和指针失效
			- c.insert(p,il); il = {a,b,c...}
			- c.insert(p,cb,ce);
		- 访问 仅vector deque string array
			- c.front() 返回容器首元素的引用
			- c.back() 返回容器尾元素的引用
			- c[n] 返回容器下标为n的元素的引用 保证下标不越界是程序员的责任 不是编译器
			- c.at() 同上 下标越界时抛出out_of_range异常
		- 删除 
			- c.pop_back() 删除容器尾元素 若容器为空 返回void
			- c.erase(p) 
				- 删除迭代器p所指定的元素 返回被删元素其后一个元素的迭代器
				- 若p指向尾元素 则返回尾后元素迭代器 也就是c.end()
				- 若p指向尾后迭代器 函数行为未定义
			- c.erase(b,e)
				- 删除be指定范围内的元素 返回e后一个元素的迭代器
				- 若e指向c.end() 则还是返回c.end()
			- c.clear() 删除容器中所有元素 并返回void
			- 删除deque首尾之外的元素 vector和string尾元素之外的元素 都会使迭代器 引用和指针失效 因此返回迭代器可以保证迭代器始终在更新
			- 删除元素前 必须确保这些元素是存在的
		- forward_list
			- 删除某个中间元素需要把前一个元素的指针的下一个元素指向被删元素的下一个元素 但单向链表不能知道前一个元素 所以只能insert_after
			- insert_after的返回迭代器是指向最后一个插入元素的迭代器
			- erase_after的返回迭代器是被删元素之后的迭代器
			- lst.before_begin();
			- lst.cbefore_begin();
			- lst.insert_after(p,t); 
			- lst.insert_after(p,n,t);
			- lst.insert_after(p,b,e);
			- lst.insert_after(p,il); il = {a,b,c...}
			- lst.emplace_after(p,args);
			- lst.erase_after(p);
			- lst.erase_after(b,e);
		- 改变容器大小
			- c.resize(n) n > c.size()时 添加(n-c.size())个初始值到c末尾 否则丢弃末尾元素使 c.size() = n
			- c.resize(n,t) 上述情况的初始值为t
		- 容器操作可能使迭代器失效
			- 不要保存end返回的迭代器
				- 在循环中删除或添加元素导致迭代器失效后 用end判定循环的代码行为是未定义的 会引发无限循环
				- 保证每次判断时都使用更新的end迭代器
	- vector对象是如何增长的
		- 部分接口显示出分配空间
			- c.shrink_to_fit()
				- 要求deque vector string退回不需要的内存空间
				- 只是代表我们表示不再需要更多的内存空间
				- 不代表一定会退回内存空间
				- 将capacity()减少为size()大小
				- c.resize(c.size())? no resize只改变容器中元素的数量 不改变容器的capacity
			- c.capacity() 不重新分配内存时可以存放多少个元素
			- c.reserve(n) 
				- 分配至少能存n个元素的内存空间
				- 只有当需求超过当前capacity时才会重新分配内存 分配的内存至少满足需求 可能更大
				- 永远不会减少容器占用的内存空间
	- 额外的string操作
		- 构造string的其他方法
			- string s(cp,n)
			- string s(s2,pos2)
			- string s(s2,pos2,len2)
		- substr
			- s.substr(pos,n)
			- s.substr(pos) b > e raise out_of_range_error
		- 改变string的其他方法
			- 查表型 需要时回来翻看即可
			- replace
			- append
			- insert
			- find
			- rfind
			- find_first_of
			- find_last_of
			- find_lirst_not_of
			- find_last_not_of
			- compare
			- to_string()
			- stoi(s,p,b)
			- stof(s,p)
			- stod(s,p)
			- sto...
	- 容器适配器
		- 序列式容器适配器
			- stack
			- queue
			- priority_queue
		- 定义适配器
			- 默认构造
			- 拷贝构造
			- 所有适配器都需要容器有添加 删除 访问尾元素的能力 所以array forward_list容器类型完全不可以作为第二参数来重载默认容器
				- stack 要求back 所以其他序列式容器都可重载 默认是deque
				- queue 还要push front 所以 list和deque可 vector不可
				- priority_queue 不要push front 但要随机访问 所以 vector和deque可 list不可
- 第十章 泛型算法
	- 概述
		- 算法一般通过迭代器范围操作容器 迭代器令算法不依赖于容器 但算法依赖于元素类型的操作
		- 算法不改变底层容器的大小 它可能改变元素的值 也可能在容器内移动元素 但不会添加或删除元素
	- 初识
		- 只读
			- 仅接受单一迭代器来表示第二个序列的算法 都假定第二个序列至少和第一个一样长
		- 写
			- 容器大小要满足算法能写入需要写入的元素 大小指元素个数而不是可用空间
			- 算法不检查写操作
			- 由于以上两点 引入 插入迭代器 insert_iterator 插入赋值号右值元素到容器中
		- 重排
	- 定制操作
		- 向算法传递函数 
			- predicate 谓词
				- 一元谓词
				- 二元谓词
			- lambda函数
				- [capture list](parameter list) -> return type {function body}
				- capture list lambda函数定义的局部变量列表 通常为空
				- 捕获
					- 值捕获
						- 捕获的值在lambda创建时拷贝得到 在正式调用lambda前 原值的更改不会影响到lambda拿到的拷贝值
						- 非指针类型可以直接 值捕获
					- 引用捕获
						- 比如 ostream& 无法拷贝值 只能引用
						- 原则
							- 首先要确保lambda创建时对象是存在的
							- 从创建到调用lambda函数期间 对象的值可能做出过改变 是否仍是期望值
							- 可能的话 尽量减少引用捕获
					- 隐式捕获
						- 值捕获 [=]
						- 引用捕获 [&]
						- 混用
							- [=,...]
							- [&,...]
					- 可变lambda
						- mutable 如果一个lambda是值拷贝返回一个++int 那使用mutable可以在重复调用lambda时更新返回的int值 否则重复调用也只能无限++一次 由于是值拷贝 原值无论如何不受影响
						- 引用捕获也可以做到上述效果 原值也会改变
			- 参数绑定
				- bind
					- 占位符
					- 绑定引用参数 ref(param) cref(param)	
	- 再探迭代器
		- 插入迭代器
		- 流迭代器
		- 反向迭代器
		- 移动迭代器
	- 泛型算法结构
		- 5类迭代器
			- 输入迭代器 只读不写 单遍扫描 只能递增 
				- == ！=
				- ++
				- * 解引用只出现在等号右边 *iter++ 总是有效的
				- ->
			- 输出迭代器 只写不读 单遍扫描 只能递增 
				- ++
				- * 解引用只出现在等号左边
			- 前向迭代器 可读写 多遍扫描 只能递增
			- 双向迭代器 可读写 多遍扫描 可递增递减
				- --
			- 随机访问迭代器 可读写 多遍扫描 支持全部迭代器运算
				- < <= > >=
				- + += - -=
				- -
				- []
		- 算法形参模式
			- alg(beg,end,...)
			- alg(beg,end,dest,...) 要求dest迭代器的算法都默认无论写入多少数据目标空间都可容纳 一般是插入迭代器或ostream_ieterator
			- alg(beg,end,beg2,...)
			- alg(beg,end,beg2,end2,...)
		- 算法命名规范
			- 一些算法通过重载形式传递一个谓词
				- unique(beg,end)
				- unique(beg,end,comp)
			- _if版本
				- find(beg,end,val)
				- find(beg,end,pred)
			- _copy版本
	- 特定容器算法
		- 链表类型 
			- 修改指针而非元素缩短时间
				- lst.merge(lst2)
				- lst.merge(lst2,comp)
				- lst.remove(val)
				- lst.remove_if(pred)
				- lst.reverse()
				- lst.sort()
				- lst.sort(comp)
				- lst.unique()
				- lst.unique(pred)
			- splice成员 剪切lst2元素到lst p后位置
				- lst.splice(args) or flst.splice_after(args)
					- (p,lst2)
					- (p,lst2,p2)
					- (p,lst2,b,e)
- 第十一章 关联容器
	- 类型
		- 按关键字有序保存元素 使用比较运算符来组织元素
			- map 	键值对
			- set 	关键字
			- multimap	关键字可重复的map
			- multiset	关键字可重复的set
		- 无序集合 hash实现
			- unordered_map
			- unordered_set
			- unordered_multimap
			- unordered_multiset
	- 使用关联容器
		- map
			- 关联数组map就是下标不必是整数的数组
			- item.first item.second
		- set
			- item_set[key] = value
	- 概述
		- 定义关联式容器
			- 不支持push_back() push_front() 使用insert()
			- 关联式容器都是双向迭代器类型
		- 关键字类型的要求
			- 元素类型必须定义元素比较的方法 毕竟是对key先排序再放入 排序标准就是使用元素定义方法 这点和算法是一样的
			- 如果元素未提供 和算法一样 支持输入一个谓词来比大小
			- 谓词比大小遵循  严格弱序
				- if k1 <= k2 && k2 <= k1 {k1 = k2}
				- if k1 <= k2 && k2 <= k3 {k1 <= k3}
			- multiset<key,comp>
				- multiset<my_class_type,decltype(my_comp)*>
		- pair类型
			- 头文件utility
			- 默认构造函数会对其成员默认值初始化
			- 也可以使用拷贝构造给值
			- 返回值为pair的函数可以在条件语句中返回默认构造或者{}拷贝构造
			
			- 操作
				- pair<T1,T2> p;
				- pair<T1,T2> P(v1,v2);
				- pair<T1,T2> p = {v1,v2};
				- .first .second
				- make_pair(v1,v2);
				- == !=
				- < <= > >= 字典序
	- 操作
		- 类型别名 map<T1,T2>
			- key_type 		T1				set类型的key_type和value_type是一样的
			- mapped_type 	T2 				只有map类型有
			- value_type	pair<T1,T2>		解引用一个关联式容器迭代器时 得到一个value_type的值引用
		- 关联式容器迭代器
			- key_value是const的
			- map_it -> first, map_it -> second
			- 通常不对关联式容器使用泛型算法 因为key_value const特性很难用来算法遍历，改值和重排
			- 但关联式容器特化了一些算法 比泛型算法更快 更适合这个容器
		- 添加元素
			- 操作
				- c.insert(v);
				- c.emplace(args);
				- c.insert(b,e);
				- c.insert({});
				- c.insert(p,v);
				- c.emplace(p,args);
			- 返回值
				- pair<p,bool> first 指向value_type second 元素插入成功or已存在
		- 删除元素
			- c.erase(k); 	返回size_type 指出删除的元素数量
			- c.erase(p);	返回p之后元素的迭代器 未找到返回c.end()
			- c.erase(b,e);	返回e
		- map下标
			- 与vector不同 找不到map[key]时会添加key到map 序列式容器下标不越界是程序员的责任
			- 操作
				- c[k]		适用于非const的map和unordered_map
				- c.at(k)
		- 访问元素
			- c.find(k);			检查元素是否在map容器中可以用find()代替下标操作
			- c.count(k);			multimap/multiset中查找遍历所有key的mapped_value可以使用 count() + find()
			- c.lower_bound(k);		不适用于无序容器 multimap/multiset中查找遍历所有key的mapped_value也可以使用该迭代器
			- c.upper_bound(k);		如果lower_bound()和upper_bound()返回相同的迭代器 即 c.end() 那给定关键字不在容器中
			- c.equal_range(k);		最直接的方法 返回一个pair<first_match_it,last_match_it>
	- 无序容器
		- 概要
			- 哈希函数实现
			- 在某些场景下 维护元素序代价高昂 无序容器是有必要的
			- 理论上哈希实现可以获得更好的平均性能 但需要性能测试和调优
		- 操作
			- 桶管理
				- 桶接口
					- c.bucket_count()		正在使用的桶的数目
					- c.max_bucket_count()
					- c.bucket_size(n)		第n个桶中有多少元素
					- c.bucket(k)			关键字为k的元素在哪个桶中
				- 桶迭代
					- local_iterator
					- const_local_iterator
					- c.begin(n) c.end(n)	桶n的首尾元素迭代器 返回local_iterator
					- c.cbegin(n) c.cend(n) 返回const_local_iterator
				- 哈希策略
					- c.local_factor()		每个桶的平均元素数量 返回float
					- c.max_load_factor()	local_factor <= max_local_factor
											bucket_count >=n
											bucket_count > size/max_load_factor
					- c.rehash(n)
					- c.reserve(n)	
		- 对关键字的要求
			- 自定义类型的关键字需要自己提供哈希重载作为参数传到哈希模板
				- ==
				- hasher函数重载
- 第十二章 动态内存
	- 动态内存与智能指针
		- 介绍
			- new 在动态内存空间堆中为对象分配一个空间并返回一个指向该对象的指针
			- delete 接受一个动态对象的指针 销毁该对象 并释放与之关联的内存 忘记释放内存会导致内存泄漏
			- 标准库提供管理动态内存的智能指针 头文件 memory
		- 操作
			- shared_ptr与unique_ptr共有操作
				- shared_ptr<string> sp;
				- unique_ptr<string> up;
				- p 						if p 当p指向一个对象时为true if p->empty() 若p1指向类型的对象值为空
				- *p 						解引用p 获得它指向的对象
				- p -> mem 					等价于 (*p).mem
				- p.get()					返回p中所保存的指针 若p已释放其对象 则返回的指针指向的对象已经消失
				- swap(p,q)					交换指针 
				- p.swap(q)					其实.reset()就是调用了p.swap(q) 交换指针
			- shared_ptr
				- make_shared<T>(args) 		返回一个shared_ptr 指向一个动态分配的T类型的对象 用args初始化对象
				- shared_ptr<T> p(q)		p是shared_ptr指针q的拷贝 会递增q的计数器
				- p = q 					p和q都是shared_ptr 递减p的计数器并递增q的计数器 若p的引用计数变为0 则将其管理的原内存释放
				- p.unique() 				若p.unique()=1 返回true 否则false
				- p.use_count() 			返回与p共享对象的智能指针数量 可能很慢 主要用于调试
		- shared_ptr
			- 构造
				- make_shared函数 是最安全的分配和使用动态内存的方法 类似序列式容器的emplace成员 安全构造 一般可以用auto保存其指针类型
				- 来自互联网：
					make_shared安全在于：
						防止使用相同的内置指针值初始化（或reset）多个智能指针 及其导致的同一个对象被多次销毁的潜在问题 
						new一个对象并赋给shared_ptr 是分两步 
						先分配对象内存 
						再分配一个控制块内存 
						同一个动态对象被多个shared_ptr持有 
						意味着一个动态对象 多个控制块内存 
						其引用计数是分开的
						会使shared_ptr原本的设计目的失效
						而且离开作用域时
						同一个对象被销毁两次会出事
						but make_shared在分配对象内存时就同时在临近的内存分配了一个控制块
						所有后来的shared_ptr拷贝或赋值都记录在这个控制块之下
						可以起到shared_ptr统计对象持有数的作用
					make_shared劣势：
						还是控制块的问题
						weak_ptr的设计是
						当最后一个弱引用离开的时候 共享的内部信息控制块才会被销毁和释放
						这意味着
						使用make_shared构造的动态对象
						生命周期并不是shared_ptr决定的
						最后一个weak_ptr销毁时 动态对象才会被销毁
						无形中延长了其生命周期
				- 来自自己：
					注意make_shared是用于构造 构造 构造

					由于shared_ptr支持拷贝构造和拷贝赋值
					make_shared作为右值可以帮助构造shared_ptr

					作为右值就意味着
					如果make_shared封装在一个函数里
					它必须有返回值

					如果没有返回值的话
					由于make_shared对象和shared_ptr已经绑定
					一荣俱荣 一损俱损
					离开作用域时 不管局部作用域拷贝了多少个shared_ptr都会自动销毁
					make_shared动态对象也就销毁了

					也因为make_shared仅用于构造shared_ptr
					因此一个已经存在的智能指针
					哪怕是一个已经存在的空智能指针
					只能通过p1.reset(p2) 即 p1.swap(p2)的方式交换指针 重设动态对象的控制权

			- 拷贝构造和拷贝赋值
				- 共享一份在动态内存空间上的数据 每个shared_ptr都有一个关联的计数器 引用计数 reference_count
			- 自动释放对象和内存
				- reference_count = 0 时会自动调用析构函数释放其管理的对象
				- 确保无用的shared_ptr手动销毁 如果将指针保存在容器中并进行了重排 确保重排后erase掉不需要的元素 否则内存泄漏
			- 使用动态内存的三种原因：
				- 程序不知道自己需要使用多少对象	容器
				- 程序不知道所需对象的准确类型	十五章举例
				- 程序需要在多个对象间共享数据	本章举例
		- 直接管理内存
			- new
				- auto 
					- 智能指针的类型 如果new的对象初始化时使用单个初始化器 可以用auto推测类型
					- auto p1 = new auto(obj) 	可
					- auto p2 = new auto{a,bc} 	不可
				- const
				- nothrow
					- bad_alloc
						- 内存不够时无法new一个空间 抛出异常bad_alloc
					- 不想抛出异常时用 new (nothrow) obj 定位new 返回一个空指针
			- delete
				- 必须传一个指向动态对象的指针或一个空指针
				- 销毁给定指针指向的对象 并 释放对应的内存
				- 释放一块非new分配的内存 或者相同的指针释放多次 其行为是未定义的
				- 动态对象的生存期直到它被销毁为止 使用非智能指针处理动态对象时需要手动管理对象的生存期 显示释放前一直会存在
					- 也就是说 在函数体中使用到的指针 都要看看它指向的对象是否是动态对象 然后决定是在函数体处理掉 还是交给程序调用者决定
			- 使用new delete管理动态内存存在3个问题：
				- 忘记delete 内存 导致内存泄漏
				- 使用已经释放掉的对象 有时可以检测出这种错误
				- 同一块内存释放两次
				- 以上 希望大家坚持使用智能指针
			- dangling pointer 空悬指针
				- 指针所指对象已销毁 但指针依然指向其地址
				- 未初始化指针的所有缺点 空悬指针都有
				- 离开作用域前 释放掉指针关联的内存 delete之后 将nullptr赋予指针 清楚地指出该指针不再指向任何对象 然后指针离开作用域
				- 但这不解决多个指针指向同一个对象的问题
		- shared_ptr和new结合使用
			- 智能指针的构造函数是explicit的 不能通过拷贝赋值的方式构造 只能拷贝构造创建
				- shared_ptr<int> p1 = new int(1024) 	不可
				- shared_ptr<int> p1(new int(1024))		可
			- 函数体的return和返回值都显示要求智能指针型
			- 其他操作
				- shared_ptr<T> p(q);					p管理内置指针q所指向的对象
				- shared_ptr<T> p(u); 					从unique_ptr接管对象的所有权
				- shared_ptr<T> p(q,d); 				传入自定义的delete操作
				- shared_ptr<T> p(p2,d);				p是p2的拷贝 区别是p使用自定义的delete操作
				- p.reset();							若p是唯一指向该动态对象的智能指针 释放对象 将p置为空
				- p.reset(q);							令p指向q或空 经常和unique一起使用 判断是否是唯一用户 不是的话先拷贝数据再改值
				- p.reset(q,d);							释放q时调用d
			- 不要混合使用智能指针和普通指针
				- 使用普通指针访问智能指针负责的对象很危险 因为你不知道对象何时会被销毁
			- 永远不要用p.get()初始化另一个智能指针或为智能指针赋值
				- p.get()返回一个内置指针 设计场景是 向不能使用智能指针的代码传递一个内置指针 但这段代码不能delete内置指针
		- 智能指针和异常
			- 如果是普通指针 在new和delete之间出现未捕获的异常 会引起内存泄漏
			- 分配内存 但没有写析构函数来销毁内存的自定义类 使用智能指针可以有效解决以上问题
			- deleter删除器
			- 智能指针基本规范
				- 不使用相同的内置指针值初始化（或reset）多个智能指针 （注：原因见上文shared_ptr构造-来自互联网）
				- 不delete get()返回的普通指针 （注：避免发生第三条也就是第一条的惨案以及第四条）
				- 不使用get()初始化或reset另一个智能指针 （注：这和第一条使用相同的内置指针初始化多个智能指针是一样的风险）
				- 如果你使用get()返回的普通指针 记住当最后一个智能指针销毁后 该指针也无效了 （注：这违背了智能指针的设计目的）
				- 如果智能指针管理的资源不是new分配的内存 记住传一个删除器
		- unique_ptr
			- 初始化必须采用直接初始化形式 绑定到一个new返回的指针上
			- 不支持拷贝构造和拷贝赋值
			- 支持转移所有权
				- unique_ptr<string> p2(p1.release());	转移p1所有权到p2 p1置空
				- p2.reset(p3.release());				释放p2原动态对象 转移p3所有权到p2 p3置空
				- 这两个用法是推荐的使用.release()的方法 否则要么丢了指针，要么指针传给普通指针 还需要手动delete *p
			- 操作
				- unique_ptr<T> u1;						空unique_ptr 使用delete释放指针
				- unique_ptr<T,D> u2;					使用可调用对象D释放指针
				- unique_ptr<T,D> u(d);					用类型为D的对象d代替delete
				- u = nullptr;							释放u指向的对象 并将u置为空
				- u.release();							u放弃对指针的控制权 返回指针 并将u置为空
				- u.reset();							释放u指向的对象
				- u.reset(q);							令u指向q或空
				- u.reset(nullptr);						等价于u = nullptr;
		- weak_ptr
			- 不控制所指对象的生命周期的智能指针 指向一个shared_ptr指向的动态对象
			- 将一个weak_ptr绑定到shared_ptr上不会增加shared_ptr的引用计数
			- 最后一个指向对象的shared_ptr被销毁 对象就会被释放 即使有weak_ptr指向对象
			- 来自互联网：当最后一个弱引用离开的时候, 共享的内部信息控制块会被销毁和释放(共享的对象也会被释放, 如果还没有释放的话)
				which means make_shared
			- 操作
				- weak_ptr<T> w;						空weak_ptr
				- weak_ptr<T> w(sp);					指向shared_ptr指向的对象
				- w = p;								p可以是shared_ptr或weak_ptr w与p共享对象
				- w.reset();							将w置空
				- w.use_count();						与w共享的shared_ptr的数量
				- w.expired();							若w.use_count()为0 返回true 否则false
				- w.lock();								如果expired返回true 返回一个空shared_ptr 否则返回对象的shared_ptr
			- 用途
				- if条件判断w.lock()存在后在if作用域内安全共享对象
				- 不影响对象的生命周期 但可以安全访问对象
	- 动态数组
		- new和数组
			- 动态分配一个空数组是合法的
			- unique_ptr操作
				- unique_ptr<int[]> up(new int[10]);	
				- up.release() 							会自动调用delete []
				- up[i]									当一个up指向数组时 不能使用.和->运算符 但可以使用[]访问数组中的每个元素
				- delete[] p 							释放动态数组 p指向的还是动态数组的首元素
			- shared_ptr不直接支持管理动态数组 需自定义deleter 可以用lambda函数
				- shared_ptr<int> sp(new int[10],[](int* p)->{return delete[] p;});
				- sp.reset();
		- allocator类
			- 头文件memory
			- 将内存分配和对象构造分开来
			- 操作
				- allocator<T> a;						定义一个名为a的allocator对象 可以用于分配内存
				- a.allocate(n);						使用allocator对象a 分配原始的 未构造的n个类型为T的对象的空间 返回p指针
				- a.deallocate(p,n);					p必须是一个先前allocate返回的指针 n必须是创建时要求的大小
				- a.construct(p,args);					p指向的原始内存 args传递给类型为T的构造函数来构造对象
				- a.destroy(p);							对p指向的对象执行析构函数
			- 伴随算法
				- uninitilized_copy(b,e,b2);			从一个迭代器范围拷贝到原始内存 返回q指针 最后构造的元素之后的位置
				- uninitilized_copy(b,n,b2);			从迭代器首元素开始 拷贝n个元素到原始内存
				- uninitilized_fill(b,e,t);				在原始内存迭代器范围内创建对象 值为t的拷贝
				- uninitilized_fill(b,n,t);				在原始内存迭代器首元素起 创建n个 值为t的拷贝
	- 使用标准库：文本查询程序
		- 设计
			- 列出程序的操作帮助我们确定合适的数据结构
				- 容器选择
				- 类 功能 数据共享
				- 设计一个类时 真正实现成员之前先编写如何使用这个类
			- 来自自己：
				- 针对这个需求 为什么不能使用一个类解决问题？为什么需要两个类？
					- 接口固定
						由于使用者的代码要求print(cout,ts.query(s))这样的使用接口已经固定了 只能这么写
						那就需要ts.query(s)返回一个类 
						因为函数接收两个及以上返回值比较麻烦 额外的返回值需要传引用 比较曲折 传一个类会很清晰方便
						但会需要考虑多个类共享数据的问题

						换句话说 接口变了 比如 tq.query(s) tq.query_file(file)这样的接口
						那就不需要用到两个类 一个类可以搞定 也无需考虑多个类共享数据的问题
						见text_query_simple.h

						而事实上 接口固定再实现的情况比较多 大概
						所以必须习惯起来
				- 为什么需要先封装str_blob类和str_blob_ptr类？
					- 其实不用 这里主要是为了教学 学习目标可以说是 
						- 学会分离式编译
							- ld: symbol(s) not found for architecture x86_64 一般是头文件引入错误
								实测分离式编译.cpp文件都引.cpp不容易出错 否则根据提示检查
							- .h头文件中 接口声明的返回类型是没有出现过的指针类 需要先前置声明 不需要引入指针类的头文件
							- .h头文件中 需要用到其他类的具体对象 而非指针或引用时 比如用于构造函数传参 取其数据来构造时 需要引入头文件
						- 学会写一个带指针的类
						- 学会写一个简易迭代器（还是一个带指针的类）
							- 构造函数
								- 传参可以有const版本和非const版本
								- 看具体使用情况可以增加构造函数
								- 拷贝赋值 拷贝构造 析构函数 big three
							- 接口函数
								- 需要使用到其他类的具体操作时 应该在其他类的.cpp文件 也就是其他类的定义之后实现接口定义
								- 局部变量的返回值不能是引用
								- 需要修改原值时返回值必须是引用 尤其是拷贝赋值
								- 函数名最好能看得出函数是否改变类的数据 如果不改变一定要加const 共享数据 连续调用时发现某一环不是const再去改就还挺麻烦
									- 常见错误
										the object has type qualifiers that are not compatible with the member function "Str_blob::at" -- object type is: const Text_query_blob::str_blob
							- private区的数据可以是一个函数的返回对象
							- 学会写操作符重载的替代函数
								- ++ * 是成员函数
								- 比大小 == != 是友元函数
									- == 两个迭代器相等的条件：
										- 要么都是空智能指针 都不指向任何对象
										- 要么指向同一个对象的同一个位置
						- 学会使用shared_ptr共享数据
							- 智能指针的构造函数是explicit的 只能拷贝构造不能拷贝赋值
								- shared_ptr和new结合使用
									- 只能拷贝构造
								- make_shared构造函数
									- 只能构造
						- 学会使用weak_ptr检查对象是否存在
							- .lock()返回shared_ptr再判断
						- 学会使用std::size_t类型 
							size_t是标准库定义的类型 
							在不同的机器上自动调节大小 unsigned long || unsigned long long etc.
						- 学会使用static
						- 学会使用标准库提供的算法
						解法见text_query_blob.h


						这里str_blob类相当于vector<string>的适配器
						封装了vector<string>并开放了一些vector<string>的方法
						其中一些方法需要用到迭代器
						因此需要再写一个str_blob_ptr类提供迭代器操作
						我猜后续章节应该可以有不同层面的解法

						在text_query类使用自定义封装类和使用stl容器类没有不同
						抛开以上学习目标
						用using也能起到封装效果
						顺便把shared_ptr也封装进去都很方便
						见text_query_b.h