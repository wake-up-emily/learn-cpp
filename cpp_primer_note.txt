c++细节
- 第二章 变量和基本类型
	- 基本内置类型
		- 整型
			- 八进制 0开头 最多\后能读三位 "\1234" // "s4"
			- 16进制 0x开头 \后四位
	- 变量
		- 初始值
			- 列表初始化 {} 尤其编译期规避类型转换时信息丢失的风险
			- 全局变量int 初始值为0 main函数体内部int不被初始化 尝试拷贝或输出时会输出一个未定义的奇异值（1）
	- 指针
		- Nullptr
		- 指针和引用的区别
			- 指针是对象 允许拷贝和赋值 可多次赋值 可无初始值
			- 引用不是对象 只能绑定一次 必须有初始值
		- 指向指针的
			- 指针 ** ***
			- 引用 不仅改变指针所指的对象 也改变指针本身 （因为指向指针的引用就代表了指针）
	- const
		- extern 暴露变量
		- 常量引用 
			- const int 不允许通过这个引用改变原值 多个引用存在时 可以通过别的引用（或者原值）修改原值
			- int &r = 0 不可 const int &r =0 可
		- 常量指针 
			- const int *p = 42; const int *const p = 42; 新加的const保证p永远指向42
			- const int *const p3 = &v p3永远指向变量v，且p3指向常量，无法通过p3修改v的值
			- 常量指针不能被赋值 初始化如果没有值就只能一直没有值
		- 顶层const/底层const
			- const int *const p = 42; 右边顶层（p是常量），左边底层（对象是常量）
			- 拷贝操作时 顶层const不受影响 底层const要求左值和右值有相同的底层const资格 或右值可转换成左值的数据类型
			- const int 指针指到普通 int 是可以通过编译 但是 对象 还是int 以对象的意愿来说 它还是可以改值的
				int v = 42;
	    		const int *p = &v;
	    		v = 1024;
	    		cout << *p << endl; // p=1024
	    - constexpr 
	    	- 常量表达式
	    	- constexpr int *p 等价于 int *const p 把p置为顶层const
	- 处理类型
		- typedef/using
			- 使用
				- typedef double wages;
				- using wages = double;
			- 别名指代复合类型或常量时要小心
				typedef char *pstring
				const pstring cstr = 0; //cstr是指向char的常量指针
				const char *cstr = 0; //把char直接替换过去解读是不行的 这样cstr是指向const char类型的指针
		- auto
			- 一条语句只有一个数据类型
			- 忽略顶层const
			- 实际计算变量的初始值后推断类型
		- decltype
			- (()) 结果永远是引用
			- 保留顶层const
			- 不计算表达式的值 类型推导
- 第三章 字符串 向量 和数组
	- string
		- getline(cin,line)
		- .empty()
		- .size() 类型是size_type std中可以记录任意长度的string的无符号类型
		- + 
			- 运算符要求等式右边至少有一个是string类型 string s = "hello" + "world"是不行的
			- 连续 + 是从左往右 string p2 = (p1 + "hello ") + "world" 也符合上一条规范 string p2 = "hello " + "world " + s 就不行
		- string和char是两种类型 char使用 '' string使用""
		- cctype头文件中的一堆bool函数 eg. .isspace(c), .isgragh(c)不是空格但可以打印 .isxdigit(c)是16进制数字
		- for
		- [] 无符号
	- vector
		- {} 列表 vector<string> s{10} 有10个元素 初始值都是结尾为\0的空字符串
		- .push_back()
		- [] 无符号
		- iterator 
			- v.begin(), v.end()
			- ->
			- begin + (end - begin)/2 or (begin + end)/2
	- array
		- init
			- int (*p)[10] = &arr
			- int (&r)[10] = arr
		- [] 有符号
		- iterator
			- begin(ia), end(ia)
		- 多维数组
			- init
				- int ia[row][col] 二维数组
				- int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11} or int ia[3][4] = {{0,1,2,3},{4,5,6,7},{8,9,10,11}}
				- int (*p)[col] = ia 即 int (*p)[col] = &ia[0] //指针默认指向数组的首元素地址
				- int (&r)[col] = ia[1]
			- for
				- for (auto &row : ia) { //除了最内层循环 其他所有循环的控制变量都要求是引用型 否则外层循环中row被解释为int * 即数组首元素的指针 内层循环并不合法
- 第四章 表达式
	- ++
		- 后++ *p++在循环中是高效的写法
	- 逻辑运算符
	- 位运算符 & | ^(异或 11=0 其余为1)
	- 左移右移
	- sizeof
	- 类型转换
		- 强转
			- static_cast
			- const_cast
			- （reinterpret_cast）不建议使用 太容易出错了
	- 运算符优先级
- 第五章 语句
	- {} 作用域
	- 条件语句
		- if
		- case
			- char cin.get() 和 cin >> c 有区别 前者统计不到\t \n 空格之类的
			- 多个case同一出口可以合并
			- case标签必须是常量表达式
	- 循环语句
		- while
		- do while
		- for
	- 跳转语句
		- break
		- continue
	- try catch
		- 标准库定义的标准异常
	- throw
- 第六章 函数
	- 基础
		- 形参/实参
		- 局部对象
			- 局部静态对象
		- 函数声明
			- 头文件&源文件放什么
	- 参数传递
		- 值传递 形参和实参是分开独立的对象 即离开函数作用域后实参没有影响
		- 引用传递 形参通过调用实参的引用达到修改实参的目的 或通过增加引用型参数的方式 达到返回多于一个值的效果 本质还是写
		- 常值引用 函数无意对实参进行修改 在实参值较大的情况下 避免拷贝原值 更快地调用实参 达到读的目的
		- 数组形参
			- 传指针
				- 数组都是以指针的形式传递的 只有地址 不知道数组的具体大小
				- void print(const int arr[]) 等价于 void print(const int arr[10]) 实参都是 const int * 类型的
			- 传引用
			- 传多维数组
				- int (*matrix)[10] 代表一个指针指向int[10]的数组
				- int *matrix[10] 	代表一个数组 包含10个int型的元素
				- int matrix[][10] 	代表一个数组 包含10个int型的元素
		- main 命令行debug argc argv参数
		- 可变形参
		- 省略符形参
	- 返回类型和return语句
		- 返回语句可以用三元运算符
		- 不要返回局部对象的引用或指针
		- 引用返回左值
		- 递归
		- 返回数组指针
			- using
			- 尾置返回类型
			- decltype
	-函数重载
		- const
		- 函数匹配
		- 重载确定
	- 特殊用途语言特性
		- 默认实参
			- 放最后 一个参数带默认实参 其后的所有参数都必须带默认实参
		- 内联函数 inline
			- 你向编译器请求内联 编译器会看情况看决定是否内联
			- 适用于优化规模较小（75行内） 流程直接 频繁调用的函数 比如函数还调用了标准库的函数 那显然就不算是可以内联了
		- constexpr
			- 隐式指定为inline函数
			- 不一定返回常量表达式 当不是的时候 编译不会通过
		- 预处理器
			- assert
			- __FILE__
			- __LINE__
			- __TIME__
			- __DATE__ //现代编译器其实有cover这部分
	- 函数匹配
		- 候选函数
		- 可行函数
			- 二义性调用
			- 实参类型转换
				- 类型提升
				- 算数类型转换
				- const转换
				- 类类型转换
	- 函数指针
		- using
		- 尾置返回类型
		- decltype
- 第七章 类
	- 定义抽象数据类型
		- 成员函数
			- this
			- const 成员函数
			- 类作用域和成员函数
			- 在类外定义成员函数
		- 非成员函数
		- 构造函数
			- 默认构造函数
			- 初始值
			- 在类外定义构造函数
		- 拷贝 赋值和析构
	- 访问控制与封装
		- public/private
		- class/struct
		- 友元函数
	- 类的其它特性
		- inline
		- 重载
		- 可变数据成员 mutable
			- 即使一个声称是const的函数也可以修改可变数据成员的值
		- const成员函数返回*this是一个常量引用
		- 基于const的重载
			- const object只会调用const函数
			- non-const object只会调用non-const函数
			- 为了提供均能满足的两个函数 建议把实际工作的代码封装成私有函数 再去调用私有函数来使用
		- 类类型
			- 同样成员的类 类名不同则类类型不同
		- 友元
			- 类友元
			- 成员函数友元
				- 看上去比较复杂
	- 类的作用域
		- 名字查找
		- 类型名
	- 构造函数
		- 初始值
		- 初始化的顺序
		- 默认实参与构造函数
			- 如果一个构造函数为所有参数都提供了默认实参 那它实际上也定义了默认构造函数
			- 注意二义性调用
		- 委托构造函数
		- 默认构造函数的作用
			- 如果定义了其他构造函数 编译器就不会提供默认无参构造函数 最好自己写一个
			- 使用时注意 声明一个对象和声明一个无参函数的区别 （）
		- 隐式的类类型转换
			- 只出现在拷贝构造 与拷贝赋值没有关系
			- 只允许一步类类型转换
			- 类型转换不总是有效
			- explicit 防止构造函数隐式类类型转换
			- static_cast<type> 如果实在需要 可以显式转型
		- 聚合类
			- 所有成员public 无任何构造函数 无类内初始值 无基类 无virtual函数
		- 字面值常量类
			- constexpr
	- 类的静态成员
		- 声明
		- 使用
			- ::
			- 成员函数可直接调用
		- 类内初始化
			- const/ constexpr
- 第八章 IO库
	- IO类
		- iostream
		- fstream
		- sstream 
			- ifstream和istringstream都继承自itream 也就是cin怎么用这俩就能怎么用
		- IO对象无拷贝或赋值
			- 一般传引用 因为读写一个IO对象会改变其状态 传递和返回的引用不能是const
		- 状态
			- in.eof()
			- in.bad()
			- in.fail()
			- ... 一般while (in)检测就代表这些重要的flag值没有设为true
			- 循环中要先重置in.clear() 每一次循环复位in的标志状态
			- endl 表示换行并刷新缓冲区
			- cout << unitbuf 表示任何输出都立即刷新 无缓冲 cout << nonunitbuf 表示回到默认的带缓冲输出
			- 如果程序崩溃 缓冲区不会刷新
			- 任何读取操作都会先刷新关联的输出流 所以交互式系统一般会关联输入流和输出流 使读取操作前打印出用户的输入
	- 文件输入输出
		- 使用
			- ifstream fstrm(file); 关联到输入文件
			- ifstream fstrm(file,mode); 关联到输入文件并选择mode in or out
			- fstrm.open();
			- fstrm.close(); 当一个fstrm离开作用域时 .close()会自动调用
			- fstrm.is_open();
		- 文件模式
			- out 只可以对ofstream和fstream选择out模式 以out模式打开会丢失已有数据
			- in  只可以对ifstream和fstream选择in模式
			- app 以app模式打开不会丢失已有数据
			- trunc 只有当out也被设定时才可以用trunc模式 默认情况下 out模式下没有指定trunc 也会截断文件
		- string流
			- 使用
				- sstream strm; 未绑定string对象的strm 配合strm.str(s)使用
				- sstream strm(s); 绑定strm与string
				- strm.str() 返回strm所保存的str的拷贝 eg. cout << strm.str() << endl;
				- strm.str(s) 将s拷贝到strm中 返回void
			- istringstream
			- ostringstream
- 第九章 序列式容器
	- 概述
		- 所有容器都有不同程度的性能折中
			- 添加或删除元素的代价
			- 非顺序访问容器元素的代价
		- 序列式容器
			- vector 连续空间 可扩展 快速随机访问元素 在尾部之外的位子插入元素或删除元素可能很慢
			- deque 双端队列 两端可进出 双向可扩充 在头尾插入/删除元素很快 
			- list 双向链表 只支持双向顺序访问 在链表任何位置插入/删除元素都很快
			- forward_list 单向链表 只支持单向顺序访问 在链表任何位置插入/删除元素都很快
			- array 创建时分配固定大小的连续空间 可快速随机访问 不能添加或删除元素
			- string 与vector相似 但只存char 连续空间 可扩展 快速随机访问元素 在尾部之外的位子插入元素或删除元素可能很慢
		— 序列式容器选择
			- 通常 使用vector是最好的序列式容器选择 除非你有更好的选项
			- 选择容器的原则
				- 能不能选vector?
				- 程序有很多小的元素 且空间的额外开销很重要 不要选list or forward_list
				- 要求在容器的中间插入/删除元素 选list/forward_list
				- 要求随机访问元素 选vector or deque
				- 头尾要求插入/删除 但中间不需要插入/删除 选deque
				- 输入时要求向中间插入元素 使用时需要随机访问：
					- 能不能先放进去再排序？
					- 输入阶段用list 输入完成后存到vector
				- 其他情况最好看性能测试的结果
	- 容器库概览
		- 容器操作层次
			- 所有容器都提供的操作
			- 按迭代器分类容器提供的操作
			- 部分容器独有的操作
		- 容器操作类型
			- 类型别名
				- iterator
				- const_iterator
				- size_type 无符号整数类型 足以保存该容器可提供的最大容器大小
				- difference_type 带符号整数类型 足以保存两个迭代器之间的距离
				- value_type 元素类型
				- reference 左值类型 等于 value_type&
				- const_reference
			- 构造函数（6种）
				- C c; 默认构造
				- C c1(c2); 容器拷贝构造
				- C c1 = c2; 拷贝赋值
				- C c{a,b,c...}; 花括号拷贝构造
				- C c = {a,b,c...}; 花括号拷贝赋值
				- C c(b,e); 迭代器拷贝构造

				序列式容器+2种：
				- C seq(n); 包含n个元素，元素值为初始值
				- C seq(n,t); 包含n个元素，元素值为t
			- swap
				- a.swap(b);
				- swap(a,b); 通常比a.swap(b)快得多
			- 大小
				- c.size(); forward_list不支持
				- c.empty();
				- c.max_size();
			- 关系运算符
				- ==, !=
				- < <= > >=
			- 获取迭代器
				- c.begin(), c.end()
				- c.cbegin(), c.cend()
			- 反向容器
				- c.rbegin(), c.rend()
				- c.crbegin(), c.crend()
		- 迭代器
			- forward_list 不支持 --
			- 迭代器范围
				- 左闭右开区间 右指向尾元素之后的位置 [begin, end)
				- 迭代器范围的形成：
					- begin end在同一个容器或end指向容器最后一个元素之后的位置
					- end >= begin
				- begin = end时 由于左闭右开 也就是范围为空
				- begin != end时 范围至少包含一个元素 也就是begin
				- 可以递增begin若干次 使begin = end
		- 容器类型成员
			- 使用类型别名
		- begin和end成员
			- cbegin() 和 cend()配合 auto使用 eg. auto it = c.cbegin(); 其实auto就是const_iterator类型
			- 不需要写访问时应使用cbegin()和cend()
		- 容器定义和初始化
			- 不同类型的容器不能使用拷贝构造和拷贝赋值 但可以使用迭代器拷贝构造 或者c1.assign.(c2_cb,c2_ce)
			- array容器
				- array容器和内置数组的区别
					- 形式
						- int arr[] = ... 这是内置数组 不是array容器
						- array<type,n> 这是array容器 数组类型和大小一起构成了array容器
					- 拷贝
						- 内置数组不支持拷贝构造或拷贝赋值
						- array容器支持
		- 赋值和swap
			- 使用assign(仅序列式容器)
				- 允许从一个不同但相容的类型赋值 或从容器的一个子序列赋值
			- 使用swap
				- 很快 元素本身未交换 交换的是两个容器的内部数据结构
				- 除array外 swap不对任何元素进行拷贝 删除或插入操作 O(1)
				- 元素在swap过程中没有移动 意味着指向元素的迭代器 引用和指针不会失效
				- arr.swap()真正交换元素 O(n)
		- 关系运算符
			- 两个容器比大小：
				- 使用元素定义的关系运算符比大小
	- 序列式容器操作
		- 添加 除forward_list外
			- c.push_back(); 元素拷贝 不影响到提供值的原始对象
			- c.emplace_back(); 构造而非拷贝
			- c.push_front(); vector和string不支持
			- c.insert(p,n,t); 
				- 在迭代器p指向的元素之前插入n个值为t的元素 返回新添加的第一个元素的迭代器 
				- 当p指向c.begin()并开始循环调用时相当于push_front() 
				- 向一个vector string或deque插入元素会使所有指向容器的迭代器 引用和指针失效
			- c.insert(p,il); il = {a,b,c...}
			- c.insert(p,cb,ce);
		- 访问 仅vector deque string array
			- c.front() 返回容器首元素的引用
			- c.back() 返回容器尾元素的引用
			- c[n] 返回容器下标为n的元素的引用 保证下标不越界是程序员的责任 不是编译器
			- c.at() 同上 下标越界时抛出out_of_range异常
		- 删除 
			- c.pop_back() 删除容器尾元素 若容器为空 返回void
			- c.erase(p) 
				- 删除迭代器p所指定的元素 返回被删元素其后一个元素的迭代器
				- 若p指向尾元素 则返回尾后元素迭代器 也就是c.end()
				- 若p指向尾后迭代器 函数行为未定义
			- c.erase(b,e)
				- 删除be指定范围内的元素 返回e后一个元素的迭代器
				- 若e指向c.end() 则还是返回c.end()
			- c.clear() 删除容器中所有元素 并返回void
			- 删除deque首尾之外的元素 vector和string尾元素之外的元素 都会使迭代器 引用和指针失效 因此返回迭代器可以保证迭代器始终在更新
			- 删除元素前 必须确保这些元素是存在的
		- forward_list
			- 删除某个中间元素需要把前一个元素的指针的下一个元素指向被删元素的下一个元素 但单向链表不能知道前一个元素 所以只能insert_after
			- insert_after的返回迭代器是指向最后一个插入元素的迭代器
			- erase_after的返回迭代器是被删元素之后的迭代器
			- lst.before_begin();
			- lst.cbefore_begin();
			- lst.insert_after(p,t); 
			- lst.insert_after(p,n,t);
			- lst.insert_after(p,b,e);
			- lst.insert_after(p,il); il = {a,b,c...}
			- lst.emplace_after(p,args);
			- lst.erase_after(p);
			- lst.erase_after(b,e);
		- 改变容器大小
			- c.resize(n) n > c.size()时 添加(n-c.size())个初始值到c末尾 否则丢弃末尾元素使 c.size() = n
			- c.resize(n,t) 上述情况的初始值为t
		- 容器操作可能使迭代器失效
			- 不要保存end返回的迭代器
				- 在循环中删除或添加元素导致迭代器失效后 用end判定循环的代码行为是未定义的 会引发无限循环
				- 保证每次判断时都使用更新的end迭代器
	- vector对象是如何增长的
		- 部分接口显示出分配空间
			- c.shrink_to_fit()
				- 要求deque vector string退回不需要的内存空间
				- 只是代表我们表示不再需要更多的内存空间
				- 不代表一定会退回内存空间
				- 将capacity()减少为size()大小
				- c.resize(c.size())? no resize只改变容器中元素的数量 不改变容器的capacity
			- c.capacity() 不重新分配内存时可以存放多少个元素
			- c.reserve(n) 
				- 分配至少能存n个元素的内存空间
				- 只有当需求超过当前capacity时才会重新分配内存 分配的内存至少满足需求 可能更大
				- 永远不会减少容器占用的内存空间
	- 额外的string操作
		- 构造string的其他方法
			- string s(cp,n)
			- string s(s2,pos2)
			- string s(s2,pos2,len2)
		- substr
			- s.substr(pos,n)
			- s.substr(pos) b > e raise out_of_range_error
		- 改变string的其他方法
			- 查表型 需要时回来翻看即可
			- replace
			- append
			- insert
			- find
			- rfind
			- find_first_of
			- find_last_of
			- find_lirst_not_of
			- find_last_not_of
			- compare
			- to_string()
			- stoi(s,p,b)
			- stof(s,p)
			- stod(s,p)
			- sto...
	- 容器适配器
		- 序列式容器适配器
			- stack
			- queue
			- priority_queue
		- 定义适配器
			- 默认构造
			- 拷贝构造
			- 所有适配器都需要容器有添加 删除 访问尾元素的能力 所以array forward_list容器类型完全不可以作为第二参数来重载默认容器
				- stack 要求back 所以其他序列式容器都可重载 默认是deque
				- queue 还要push front 所以 list和deque可 vector不可
				- priority_queue 不要push front 但要随机访问 所以 vector和deque可 list不可
- 第十章 泛型算法
	- 概述
		- 算法一般通过迭代器范围操作容器 迭代器令算法不依赖于容器 但算法依赖于元素类型的操作
		- 算法不改变底层容器的大小 它可能改变元素的值 也可能在容器内移动元素 但不会添加或删除元素
	- 初识
		- 只读
			- 仅接受单一迭代器来表示第二个序列的算法 都假定第二个序列至少和第一个一样长
		- 写
			- 容器大小要满足算法能写入需要写入的元素 大小指元素个数而不是可用空间
			- 算法不检查写操作
			- 由于以上两点 引入 插入迭代器 insert_iterator 插入赋值号右值元素到容器中
		- 重排
	- 定制操作
		- 向算法传递函数 
			- predicate 谓词
				- 一元谓词
				- 二元谓词
			- lambda函数
				- [capture list](parameter list) -> return type {function body}
				- capture list lambda函数定义的局部变量列表 通常为空
				- 捕获
					- 值捕获
						- 捕获的值在lambda创建时拷贝得到 在正式调用lambda前 原值的更改不会影响到lambda拿到的拷贝值
						- 非指针类型可以直接 值捕获
					- 引用捕获
						- 比如 ostream& 无法拷贝值 只能引用
						- 原则
							- 首先要确保lambda创建时对象是存在的
							- 从创建到调用lambda函数期间 对象的值可能做出过改变 是否仍是期望值
							- 可能的话 尽量减少引用捕获
					- 隐式捕获
						- 值捕获 [=]
						- 引用捕获 [&]
						- 混用
							- [=,...]
							- [&,...]
					- 可变lambda
						- mutable 如果一个lambda是值拷贝返回一个++int 那使用mutable可以在重复调用lambda时更新返回的int值 否则重复调用也只能无限++一次 由于是值拷贝 原值无论如何不受影响
						- 引用捕获也可以做到上述效果 原值也会改变
			- 参数绑定
				- bind
					- 占位符
					- 绑定引用参数 ref(param) cref(param)	
	- 再探迭代器
		- 插入迭代器
		- 流迭代器
		- 反向迭代器
		- 移动迭代器
	- 泛型算法结构
		- 5类迭代器
			- 输入迭代器 只读不写 单遍扫描 只能递增 
				- == ！=
				- ++
				- * 解引用只出现在等号右边 *iter++ 总是有效的
				- ->
			- 输出迭代器 只写不读 单遍扫描 只能递增 
				- ++
				- * 解引用只出现在等号左边
			- 前向迭代器 可读写 多遍扫描 只能递增
			- 双向迭代器 可读写 多遍扫描 可递增递减
				- --
			- 随机访问迭代器 可读写 多遍扫描 支持全部迭代器运算
				- < <= > >=
				- + += - -=
				- -
				- []
		- 算法形参模式
			- alg(beg,end,...)
			- alg(beg,end,dest,...) 要求dest迭代器的算法都默认无论写入多少数据目标空间都可容纳 一般是插入迭代器或ostream_ieterator
			- alg(beg,end,beg2,...)
			- alg(beg,end,beg2,end2,...)
		- 算法命名规范
			- 一些算法通过重载形式传递一个谓词
				- unique(beg,end)
				- unique(beg,end,comp)
			- _if版本
				- find(beg,end,val)
				- find(beg,end,pred)
			- _copy版本
	- 特定容器算法
		- 链表类型 
			- 修改指针而非元素缩短时间
				- lst.merge(lst2)
				- lst.merge(lst2,comp)
				- lst.remove(val)
				- lst.remove_if(pred)
				- lst.reverse()
				- lst.sort()
				- lst.sort(comp)
				- lst.unique()
				- lst.unique(pred)
			- splice成员 剪切lst2元素到lst p后位置
				- lst.splice(args) or flst.splice_after(args)
					- (p,lst2)
					- (p,lst2,p2)
					- (p,lst2,b,e)