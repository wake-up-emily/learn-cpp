c++细节
- 第二章 变量和基本类型
	- 基本内置类型
		- 算数类型
			- 整型
				- char 8位
				- int 16位
				- long 32位
				- long long 64位
			- 浮点型
				- float 6位有效数字
				- double 10位有效数字
			- 使用建议
				- int 整数运算
				- 确保不可能为负的值 用无符号
				- 算术表达式不要使用char or bool 不同机器char不一定是有符号或无符号 运算容易出问题
				- double 浮点运算
		- 类型转换
			- 带符号 无符号
				- 注意不要混用带符号型和无符号型
				- 无符号和负数判断时不能在一起 无符号数总是小于一个负数 不要在循环判定中使用无符号类型 尤其是 --i 这种操作 无符号类型
		- 字面值常量
			- 整数和浮点型字面值
				- 8进制 0开头
				- 16进制 0x开头
			- 字符串型字面值
				- char 'a'
				- string "a" 其实是char数组后加一个'\0'结尾符 'a'+'\0'
			- 转义序列 
				- 当做一个字符来使用
					- 换行 \n
					- 制表 \t
					- 回车 \r
					- 反斜线 \\
				- 泛化转义序列
					- 8进制 最多\后能读三位 "\1234" // "s4"
					- 16进制 \x 后能读四位
			- 布尔字面值 true false
			- 指针字面值 nullptr
	- 变量
		- 介绍
			变量提供一个具名的 供程序操作的存储空间 
			C++中每个变量都有其数据类型 
			数据类型决定变量所占内存空间的大小和布局方式 值的范围 变量参与的运算等
			变量value 对象object 一般可以互换使用 
			（对象：一块能存数据并具有某种类型的内存空间）
		- 变量定义 
			- 初始值
				- = 用于初始化 也用于赋值 初始化和赋值在C++是两种不同的操作
					初始化：创建变量时给一个初始值
					赋值：把已有对象的当前值擦除 给一个新值
			- 列表初始化 {} 
				- 尤其编译期规避类型转换时信息丢失的风险
			- 默认初始化
				- string 一个空串 '\0'
				- int 0
		- 变量声明和定义的关系
			- extern 
			- 变量只能定义一次 但可以多次声明
		- 标识符
			- c++关键字 73个 操作符替代名 11个
			- 变量命名规范
				- 体现含义
				- 小写
				- 自定义类大写字母开头
		- 名字的作用域 {}
			- 全局作用域 main
				- 全局变量int 初始值为0 main函数体内部int不被初始化是未定义的行为 
				尝试拷贝或输出时会输出一个未定义的奇异值（1）//139497509
			- 建议第一次使用变量时再定义它
	- 复合类型
		- 引用 &（左值引用）
			- T val{};
			- T &r = val;
			- 引用必须初始化 和具有初始值的对象绑定在一起
			- 引用即别名 （注：美化的指针 看到的是绑定对象的地址和大小）
		- 指针 *
			- Nullptr
			- 指针和引用的区别
				- 指针是对象 允许拷贝和赋值 可多次赋值 可无初始值
				- 引用不是对象 只能绑定一次 必须有初始值
			- 获取对象的地址
				- T val;
				- T *p = &val;
			- 指针值（地址）的四种状态：
				- 指向一个对象
				- 指向紧邻对象所占空间的下一个位置
				- 空指针
				- 无效指针 试图拷贝或访问无效指针都会引发错误 编译器不会检查此类错误 未定义的行为
			- 利用指针访问对象
				- 解引用 *p （注：指针是对象 *其实是操作符重载）
			- 空指针
				- T *p = nullptr || T *p = 0 （注：*p = 0是解引用对象的值并赋值为0）
				- 建议初始化所有指针 空指针操作是编译器能检查的错误 比无效指针的未定义行为好多了
			- 赋值和指针
				- 给指针赋值 相当于 存放一个新的地址 指向新的对象
				- 赋值改变的永远是左值
			- 其他指针操作
				- if (p) 任何非空指针都会返回true
				- == 3种可能：
					- 都为空
					- 都指向同一个对象
					- 都指向同一个对象的下一地址
			- void* 指针
				- 可用于存放任意类型对象的地址
				- 但可以做的操作有限 只有内存地址 不知道解析方式 只能进行指针比较和作为函数的输入输出 不能访问对象
		- 理解复合类型的声明
			- 定义多个变量
				- T v{}, *p = &v;
				- T* p1,p2; 这种写法合法 但看上去会误以为本条定义中的所有变量都是T型指针 其实p2是T型对象 不是指针
				- T* p1;
				- T p2; 这样分开写就比较清晰
			- 指向指针的
				- 指针 ** ***
				- 引用 不仅改变指针所指的对象 也改变指针本身 （因为指向指针的引用就代表了指针）
		- const
			- 介绍
				初始化变量后不允许其赋值（但不影响它作为右值赋值给别人 again: 赋值改变的永远是左值）
			- 默认状态下 const对象仅在文件内有效
				- 编译器全文替换变量名的值为初始值
				- 多个文件使用同一个const对象可以使用extern暴露变量
			- 常量引用
				- 常量引用可以指向常量对象和非常量对象（但它们以为自己指向了常量对象 所以自觉地不去改值）
				- 常量对象只能有常量引用 不能有非常量引用
				- 非常量对象可以有常量引用 也可以有非常量引用 常量引用不能用于赋值 非常量引用可以 或者直接给对象赋值也可以
				- 常量对象和常量引用使用时不能作为左值赋值 只能作为右值赋值
			- 常量指针
				- 类似常量引用
				- 但是回顾引用和指针的区别：引用只能绑定到一个具有初始值的对象 指针是一个对象 可以多次绑定
					如果要使常量指针只能一次绑定 在变量名前还需加一个const
					- const int *p = 42; const int *const p = 42; 新加的const保证p永远指向42
					- const int *const p3 = &v p3永远指向变量v，p3是常量指针 无法通过p3修改v的值
				- 常量指针不能被赋值 初始化如果没有值就只能一直没有值
			- 顶层const/底层const
				- 对常量指针来说 不能改值和不能指向别的对象是两件事
					- 顶层const 指针是常量 （离指针近的const） 不指向别的对象（但可以改值）
					- 底层const 对象是常量 （离指针远的const 数据类型） 不能改值（但可以指向别的对象）
					- 顶层+底层const 不指向别的对象 且 不能改值
						- const int *const p = 42; 右边顶层（p是常量），左边底层（对象是常量）
				- 拷贝操作 
					- 顶层const虽然支持改值 但拷贝操作不改值 对其没有影响 
					- 底层const要求左值和右值有相同的底层const资格 或右值可转换成左值的数据类型
		    - constexpr 
		    	- 常量表达式 值不会改变且在编译过程中就能得到值的表达式
		    	- constexpr int *p 等价于 int *const p 把p置为顶层const
		- 处理类型
			- 目的
				- 类型名难记 复杂
				- 类型的真正用途和含义 （别说多人经手的代码了 一个人写的也可能忘）
			- 类型别名 typedef/using
				- 使用
					- typedef double wages;
					- using wages = double;
				- 指针 常量和 类型别名
					- 回顾顶层const的语法：定义时在变量名前加一个const
					- 当有类型别名时
						- 类型别名含const 底层const
						- 类型别名不含const 定义时在类型别名前加一个const 顶层const
						- 可以说 使用类型别名时 底层const如果有的话 会在类型别名里指定 别名之外就是顶层const
					- using int_ptr = int*;
					    int i(42), i2(1024);
					    const int_ptr p = &i;
					    // p = &i2; //顶层const不能指向别的对象 编译不通过
					    *p = 1024; //顶层const可以改值 编译通过
					    cout << *p << endl; //1024
				    - using int_ptr = const int*;
					    int i(42), i2(1024);
					    int_ptr p = &i;
					    p = &i2; //底层const可以指向别的对象 这里可
					    // *p = 1024; //顶层const可以改值 这里不可
					    cout << *p << endl; //1024
			- 类型说明符 auto
				- 目的
					- 声明变量时清楚地知道类型这很难（虽然侯捷老师说c++程序员就是应该了然于胸）
					- 注：本书大量案例是auto和迭代器类型的配合使用
				- 一条语句只有一个数据类型
				- 忽略顶层const
				- 实际计算变量的初始值后推断类型
			- 类型指示符 decltype
				- 目的
					- 希望从表达式推断变量类型 但不希望用该表达式的值初始化变量
						编译器会分析表达式推导类型 但不进行实际运算
				- 保留顶层const
				- (()) 结果是引用类型
				- (*p) 解引用得到引用类型 引用类型必须初始化
					- decltype(*p) c; //不可
- 第三章 字符串 向量 和数组
	- 命名空间 using声明
		- using namespace::name;
		- 每个名字都需要独立的using声明
		- 头文件不应包含using声明
	- 标准库类型 string
		- 定义和初始化string对象
			- 操作
				- string s;
				- string s2(s1);
				- string s2 = s1;
				- string s("value");
				- string s = "value";
				- string s(n,'char');			连续n个字符c组成的字符串
				- string s = (n,'char'); 		其实是先生成tmp临时变量 再赋值给s
		- string对象上的操作
			- 操作
				- os << s;						写	
				- is >> s;						读	读未知数量的string对象 通常while循环
				- getline(is,s);				读一整行 通常while循环
				- s.empty();					bool
				- s.size();						string::size_type 一个无符号值 
					- 不要混用size_type和int 强转类型时负数int会转成一个很大的正数 因此无符号数总是小于一个负数
					- 来自互联网：size_type和size_t的区别
						- size_t is defined as the type used for the size of an object and is platform dependent.
						- container::size_type is the type that is used for the number of elements in the container and is container dependent.
						- All std containers use size_t as the size_type, but each independent library vendor chooses a type that it finds appropriate for its container.
						- If you look at qt, you'll find that the size_type of Qt containers is version dependent. In Qt3 it was unsigned int and in Qt4 it was changed to int.
				- s[n];							
					- 返回s字符串第n个位置的引用 位置从0开始计数
					- string::size_type n 实际使用时需要检查n是否<s.size()
				- s1 + s2;
					- string p2 = "hello " + "world " + s 不行
					- 因为按照运算符重载的法则 两个运算对象其一必须是string类型才能用string类型的+运算符重载
					- s1 + "hello" 可
					- "hello" + "world" 不可						
				- s1 = s2;
				- s1 == s2;						长度相同 包含字符也相同
				- s1 != s2;
				- < <= > >= 					字典序 大小写敏感
		- 处理string对象中的字符
			- 操作
				- isalnum(c);					char是 	字母或数字	为真
				- isslpha(c);					char是 	字母 		为真
				- isdigit(c);					char是 	数字	 		为真
				- isxdigit(c);					char是	16进制数字	为真
				- ispunct(c);					char是 	标点			为真
				- isspace(c);					char是	空白			为真
				- isprint(c);					char是 	可打印字符 	为真
				- isgragh(c);					不是空格但可以打印		为真
				- islower(c);
				- isupper(c);
				- tolower(c);
				- toupper(c);
			- 处理每个字符 使用for循环
				- for (declaration : expression)
					statement
					- 逻辑运算符 &&
			- 处理部分字符
				- []
	- 标准库类型 vector
		- 介绍
			- 标准库容器之一 使用时需要声明
				#include <vector>
				using std::vector;
			- vector是模板而非类型 使用时需要提供额外信息数据类型T
		- 定义和初始化vector对象
			- 操作
				- vector<T> v;					v是一个空vector容器 按照T类型元素初始化 常用 先创建空容器再逐一添加元素
				- vector<T> v2(v1);				
				- vector<T> v2 = v1;
				- vector<T> v(n,val);
				- vector<T> v(n);				n个T类型的元素 值为T类型元素初始值
				- vector<T> v{a,b,c...};
				- vector<T> v = {a,b,c...};
		- 向vector对象中添加元素
			- 操作
				- v.empty();
				- v.size();
				- v.push_back(val);				常用于for循环
				- v[n]							返回容器第n个位置上元素的引用 注意事项同string s[n]
				- v1 = v2;
				- v1 = {a,b,c...};
				- v1 == v2;						容器所含元素数量相同 每个位置的元素相同（使用数据类型定义的比较方法来比较）
				- v1 != v2;
				- < <= > >= 					字典序
		- 其他vector操作
			- iterator 
				- v.begin(), v.end()
				- ->
				- begin + (end - begin)/2 or (begin + end)/2 前者 代表距离移动 后者加法无意义
	- 迭代器介绍
		- 使用迭代器
			- 操作
				- *iter;							解引用 返回迭代器所指元素的引用
				- iter->mem;						
					- 相当于 (*iter).mem; 
					- 解引用不加括号时试图访问迭代器对象的mem成员再解引用 引入新符号避免歧义
				- ++iter;							返回容器的下一个元素
				- --iter;							返回容器的上一个元素
				- iter1 == iter2;
					- 回顾指针 == 的3种可能：
						- 都为空
						- 都指向同一个对象
						- 都指向同一个对象的下一地址					
					- 两个迭代器相等的条件：
						- 都指向同一个对象
						- 都指向同一个对象的下一地址	
				- iter1 != iter2;
			- 移动迭代器
				- for (auto it=s.begin();it!=s.end();++it) {
					 *it = toupper(*it); 
					 }
				- for (auto it=s.cbegin();it!=s.cend();++it) {
					 cout << *it; 
					 } 
				 cout << endl;
			 - 迭代器类型
			 	- C<T>::iterator
			 	- C<T>::const_iterator 		类似底层const 可以读取不能改值
		 	- begin和end运算符
		 		- 如果对象是const的 则返回const_iterator
		 		- 如果对象不是		  返回iterator
	 		- 结合解引用和成员访问操作
	 			- 解引用最好加括号
			- 某些对vector对象的操作会使迭代器失效
				- 使用了迭代器的循环体 不要向容器添加元素
		- 迭代器运算
			- 操作
				- iter + n 					从原迭代器的位置向前推进n个位置 得到一个新的迭代器
				- iter - n 					从原迭代器的位置向后回退n个位置 得到一个新的迭代器
				- iter += n
				- iter -= n
				- iter1 - iter2 			得到距离值
				- < <= > >= 				同一个容器中迭代器位置的比较
	- 内置数组
		- 定义和初始化内置数组
			- 操作
				- int a[] = {0,1,2};
				- int a[3] = {0,1};
			- 不允许拷贝和赋值
			- init
				- int (*p)[10] = &arr
				- int (&r)[10] = arr
				- 数组指针一定要加括号
					- int (*p)[10] 指针指向10个int元素的数组
					- int *p[10] == int* p[10] 一个数组 元素是10个int型指针
		- 访问数组元素
			- [n] 							size_t类型 和size_type一样需下标范围检查
		- 指针和数组
			- 指针也是迭代器
				- 指针默认指向数组/容器的首元素
			- 标准库函数begin(arr), end(arr) 非成员函数
			- 指针运算
				- 支持所有迭代器运算
				- 指针相减 得到的值为ptrdiff_t的标准库类型 类似有符号的size_t
			- 下标和指针
				- 内置数组的下标运算支持负值
		- c风格字符串
	- 多维数组
		- 数组的数组 不是真正的多维数组
		- 初始化
			- int ia[row][col] 二维数组
			- int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11} or int ia[3][4] = {{0,1,2,3},{4,5,6,7},{8,9,10,11}}
		- 下标引用
			- int (*p)[col] = ia 即 int (*p)[col] = &ia[0][col] 回顾：指针默认指向数组的首元素地址
			- int (&r)[col] = ia[1] 把含col个元素的r绑定到同样每行具有col个元素的ia的第二行上
		- for
			- 除了最内层循环 其他所有循环的控制变量都要求是引用型
				否则外层循环中row被解释为int * 即数组首元素的指针 内层循环并不合法
		- 类型别名可以简化多维数组的指针
- 第四章 表达式
	- ++
		- 后++ *p++在循环中是高效的写法 返回值后++
	- 逻辑运算符
	- 位运算符 & | ^(异或 11=0 其余为1)
	- 左移右移
	- sizeof 	返回一个表达式或一个类型名字所占的字节数
	- 类型转换
		- 强转
			- static_cast
			- const_cast
			- （reinterpret_cast）不建议使用 太容易出错了
	- 运算符优先级
- 第五章 语句
	- {} 作用域
	- 条件语句
		- if
		- case
			- char cin.get() 和 cin >> c 有区别 前者统计不到\t \n 空格之类的
			- 多个case同一出口可以合并
			- case标签必须是常量表达式
	- 循环语句
		- while
		- do while
		- for
	- 跳转语句
		- break
		- continue
	- try catch
		- 标准库定义的标准异常
	- throw
- 第六章 函数
	- 基础
		- 形参/实参
		- 局部对象
			- 局部静态对象
		- 函数声明
			- 头文件&源文件放什么
	- 参数传递
		- 值传递 形参和实参是分开独立的对象 即离开函数作用域后实参没有影响
		- 引用传递 形参通过调用实参的引用达到修改实参的目的 或通过增加引用型参数的方式 达到返回多于一个值的效果 本质还是写
		- 常值引用 函数无意对实参进行修改 在实参值较大的情况下 避免拷贝原值 更快地调用实参 达到读的目的
		- 数组形参
			- 传指针
				- 数组都是以指针的形式传递的 只有地址 不知道数组的具体大小
				- void print(const int arr[]) 等价于 void print(const int arr[10]) 实参都是 const int * 类型的
			- 传引用
			- 传多维数组
				- 回顾
					- int (*matrix)[10] 代表一个指针指向int[10]的数组
					- int *matrix[10] 	代表一个数组 包含10个int型的指针
					- int matrix[][10] 	代表一个指针指向int[10]的数组 因为编译器会忽略第一个维度
		- main 命令行debug argc argv参数
		- 可变形参
		- 省略符形参
	- 返回类型和return语句
		- 返回语句可以用三元运算符
		- 不要返回局部对象的引用或指针
		- 引用返回左值
		- 递归
		- 返回数组指针
			- using
			- 尾置返回类型
			- decltype
	-函数重载
		- const
		- 函数匹配
		- 重载确定
	- 特殊用途语言特性
		- 默认实参
			- 放最后 一个参数带默认实参 其后的所有参数都必须带默认实参
		- 内联函数 inline
			- 你向编译器请求内联 编译器会看情况看决定是否内联
			- 适用于优化规模较小（75行内） 流程直接 频繁调用的函数 比如函数还调用了标准库的函数 那显然就不算是可以内联了
		- constexpr
			- 隐式指定为inline函数
			- 不一定返回常量表达式 当不是的时候 编译不会通过
		- 预处理器
			- assert
			- __FILE__
			- __LINE__
			- __TIME__
			- __DATE__ //现代编译器其实有cover这部分
	- 函数匹配
		- 候选函数
		- 可行函数
			- 二义性调用
			- 实参类型转换
				- 类型提升
				- 算数类型转换
				- const转换
				- 类类型转换
	- 函数指针
		- using
		- 尾置返回类型
		- decltype
- 第七章 类
	- 定义抽象数据类型
		- 成员函数
			- this
			- const 成员函数
			- 类作用域和成员函数
			- 在类外定义成员函数
		- 非成员函数
		- 构造函数
			- 默认构造函数
			- 初始值
			- 在类外定义构造函数
		- 拷贝 赋值和析构
	- 访问控制与封装
		- public/private
		- class/struct
		- 友元函数
	- 类的其它特性
		- inline
		- 重载
		- 可变数据成员 mutable
			- 即使一个声称是const的函数也可以修改可变数据成员的值
		- const成员函数返回*this是一个常量引用
		- 基于const的重载
			- const object只会调用const函数
			- non-const object只会调用non-const函数
			- 为了提供均能满足的两个函数 建议把实际工作的代码封装成私有函数 再去调用私有函数来使用
		- 类类型
			- 同样成员的类 类名不同则类类型不同
		- 友元
			- 类友元
			- 成员函数友元
				- 看上去比较复杂
	- 类的作用域
		- 名字查找
		- 类型名
	- 构造函数
		- 初始值
		- 初始化的顺序
		- 默认实参与构造函数
			- 如果一个构造函数为所有参数都提供了默认实参 那它实际上也定义了默认构造函数
			- 注意二义性调用
		- 委托构造函数
		- 默认构造函数的作用
			- 如果定义了其他构造函数 编译器就不会提供默认无参构造函数 最好自己写一个
			- 使用时注意 声明一个对象和声明一个无参函数的区别 （）
		- 隐式的类类型转换
			- 只出现在拷贝构造 与拷贝赋值没有关系
			- 只允许一步类类型转换
			- 类型转换不总是有效
			- explicit 防止构造函数隐式类类型转换
			- static_cast<type> 如果实在需要 可以显式转型
		- 聚合类
			- 所有成员public 无任何构造函数 无类内初始值 无基类 无virtual函数
		- 字面值常量类
			- constexpr
	- 类的静态成员
		- 声明
		- 使用
			- ::
			- 成员函数可直接调用
		- 类内初始化
			- const/ constexpr
- 第八章 IO库
	- IO类
		- iostream
		- fstream
		- sstream 
			- ifstream和istringstream都继承自itream 也就是cin怎么用这俩就能怎么用
		- IO对象无拷贝或赋值
			- 一般传引用 因为读写一个IO对象会改变其状态 传递和返回的引用不能是const
		- 状态
			- in.eof()
			- in.bad()
			- in.fail()
			- ... 一般while (in)检测就代表这些重要的flag值没有设为true
			- 循环中要先重置in.clear() 每一次循环复位in的标志状态
			- endl 表示换行并刷新缓冲区
			- cout << unitbuf 表示任何输出都立即刷新 无缓冲 cout << nonunitbuf 表示回到默认的带缓冲输出
			- 如果程序崩溃 缓冲区不会刷新
			- 任何读取操作都会先刷新关联的输出流 所以交互式系统一般会关联输入流和输出流 使读取操作前打印出用户的输入
	- 文件输入输出
		- 使用
			- ifstream fstrm(file); 关联到输入文件
			- ifstream fstrm(file,mode); 关联到输入文件并选择mode in or out
			- fstrm.open();
			- fstrm.close(); 当一个fstrm离开作用域时 .close()会自动调用
			- fstrm.is_open();
		- 文件模式
			- out 只可以对ofstream和fstream选择out模式 以out模式打开会丢失已有数据
			- in  只可以对ifstream和fstream选择in模式
			- app 以app模式打开不会丢失已有数据
			- trunc 只有当out也被设定时才可以用trunc模式 默认情况下 out模式下没有指定trunc 也会截断文件
		- string流
			- 使用
				- sstream strm; 未绑定string对象的strm 配合strm.str(s)使用
				- sstream strm(s); 绑定strm与string
				- strm.str() 返回strm所保存的str的拷贝 eg. cout << strm.str() << endl;
				- strm.str(s) 将s拷贝到strm中 返回void
			- istringstream
			- ostringstream
- 第九章 序列式容器
	- 概述
		- 所有容器都有不同程度的性能折中
			- 添加或删除元素的代价
			- 非顺序访问容器元素的代价
		- 序列式容器
			- vector 连续空间 可扩展 快速随机访问元素 在尾部之外的位子插入元素或删除元素可能很慢
			- deque 双端队列 两端可进出 双向可扩充 在头尾插入/删除元素很快 
			- list 双向链表 只支持双向顺序访问 在链表任何位置插入/删除元素都很快
			- forward_list 单向链表 只支持单向顺序访问 在链表任何位置插入/删除元素都很快
			- array 创建时分配固定大小的连续空间 可快速随机访问 不能添加或删除元素
			- string 与vector相似 但只存char 连续空间 可扩展 快速随机访问元素 在尾部之外的位子插入元素或删除元素可能很慢
		— 序列式容器选择
			- 通常 使用vector是最好的序列式容器选择 除非你有更好的选项
			- 选择容器的原则
				- 能不能选vector?
				- 程序有很多小的元素 且空间的额外开销很重要 不要选list or forward_list
				- 要求在容器的中间插入/删除元素 选list/forward_list
				- 要求随机访问元素 选vector or deque
				- 头尾要求插入/删除 但中间不需要插入/删除 选deque
				- 输入时要求向中间插入元素 使用时需要随机访问：
					- 能不能先放进去再排序？
					- 输入阶段用list 输入完成后存到vector
				- 其他情况最好看性能测试的结果
	- 容器库概览
		- 容器操作层次
			- 所有容器都提供的操作
			- 按迭代器分类容器提供的操作
			- 部分容器独有的操作
		- 容器操作类型
			- 类型别名
				- iterator
				- const_iterator
				- size_type 无符号整数类型 足以保存该容器可提供的最大容器大小
				- difference_type 带符号整数类型 足以保存两个迭代器之间的距离
				- value_type 元素类型
				- reference 左值类型 等于 value_type&
				- const_reference
			- 构造函数（6种）
				- C c; 默认构造
				- C c1(c2); 容器拷贝构造
				- C c1 = c2; 拷贝赋值
				- C c{a,b,c...}; 花括号拷贝构造
				- C c = {a,b,c...}; 花括号拷贝赋值
				- C c(b,e); 迭代器拷贝构造

				序列式容器+2种：
				- C seq(n); 包含n个元素，元素值为初始值
				- C seq(n,t); 包含n个元素，元素值为t
			- swap
				- a.swap(b);
				- swap(a,b); 通常比a.swap(b)快得多 原因见下
			- 大小
				- c.size(); forward_list不支持
				- c.empty();
				- c.max_size();
			- 关系运算符
				- ==, !=
				- < <= > >=
			- 获取迭代器
				- c.begin(), c.end()
				- c.cbegin(), c.cend()
			- 反向容器
				- c.rbegin(), c.rend()
				- c.crbegin(), c.crend()
		- 迭代器
			- forward_list 不支持 --
			- 迭代器范围
				- 左闭右开区间 右指向尾元素之后的位置 [begin, end)
				- 迭代器范围的形成：
					- begin end在同一个容器或end指向容器最后一个元素之后的位置
					- end >= begin
				- begin = end时 由于左闭右开 也就是范围为空
				- begin != end时 范围至少包含一个元素 也就是begin
				- 可以递增begin若干次 使begin = end
		- 容器类型成员
			- 使用类型别名
		- begin和end成员
			- cbegin() 和 cend()配合 auto使用 eg. auto it = c.cbegin(); 其实auto就是const_iterator类型
			- 不需要写访问时应使用cbegin()和cend()
		- 容器定义和初始化
			- 不同类型的容器不能使用拷贝构造和拷贝赋值 但可以使用迭代器拷贝构造 或者c1.assign.(c2_cb,c2_ce)
			- array容器
				- array容器和内置数组的区别
					- 形式
						- int arr[] = ... 这是内置数组 不是array容器
						- array<type,n> 这是array容器 数组类型和大小一起构成了array容器
					- 拷贝
						- 内置数组不支持拷贝构造或拷贝赋值
						- array容器支持
		- 赋值和swap
			- 使用assign(仅序列式容器)
				- 允许从一个不同但相容的类型赋值 或从容器的一个子序列赋值
			- 使用swap
				- 很快 元素本身未交换 交换的是两个容器的内部数据结构
				- 除array外 swap不对任何元素进行拷贝 删除或插入操作 O(1)
				- 元素在swap过程中没有移动 意味着指向元素的迭代器 引用和指针不会失效
				- arr.swap()真正交换元素 O(n)
		- 关系运算符
			- 两个容器比大小：
				- 使用元素定义的关系运算符比大小
	- 序列式容器操作
		- 添加 除forward_list外
			- c.push_back(); 元素拷贝 不影响到提供值的原始对象
			- c.emplace_back(); 构造而非拷贝
			- c.push_front(); vector和string不支持
			- c.insert(p,n,t); 
				- 在迭代器p指向的元素之前插入n个值为t的元素 返回新添加的第一个元素的迭代器 
				- 当p指向c.begin()并开始循环调用时相当于push_front() 
				- 向一个vector string或deque插入元素会使所有指向容器的迭代器 引用和指针失效
			- c.insert(p,il); il = {a,b,c...}
			- c.insert(p,cb,ce);
		- 访问 仅vector deque string array
			- c.front() 返回容器首元素的引用
			- c.back() 返回容器尾元素的引用
			- c[n] 返回容器下标为n的元素的引用 保证下标不越界是程序员的责任 不是编译器
			- c.at() 同上 下标越界时抛出out_of_range异常
		- 删除 
			- c.pop_back() 删除容器尾元素 若容器为空 返回void
			- c.erase(p) 
				- 删除迭代器p所指定的元素 返回被删元素其后一个元素的迭代器
				- 若p指向尾元素 则返回尾后元素迭代器 也就是c.end()
				- 若p指向尾后迭代器 函数行为未定义
			- c.erase(b,e)
				- 删除be指定范围内的元素 返回e后一个元素的迭代器
				- 若e指向c.end() 则还是返回c.end()
			- c.clear() 删除容器中所有元素 并返回void
			- 删除deque首尾之外的元素 vector和string尾元素之外的元素 都会使迭代器 引用和指针失效 因此返回迭代器可以保证迭代器始终在更新
			- 删除元素前 必须确保这些元素是存在的
		- forward_list
			- 删除某个中间元素需要把前一个元素的指针的下一个元素指向被删元素的下一个元素 但单向链表不能知道前一个元素 所以只能insert_after
			- insert_after的返回迭代器是指向最后一个插入元素的迭代器
			- erase_after的返回迭代器是被删元素之后的迭代器
			- lst.before_begin();
			- lst.cbefore_begin();
			- lst.insert_after(p,t); 
			- lst.insert_after(p,n,t);
			- lst.insert_after(p,b,e);
			- lst.insert_after(p,il); il = {a,b,c...}
			- lst.emplace_after(p,args);
			- lst.erase_after(p);
			- lst.erase_after(b,e);
		- 改变容器大小
			- c.resize(n) n > c.size()时 添加(n-c.size())个初始值到c末尾 否则丢弃末尾元素使 c.size() = n
			- c.resize(n,t) 上述情况的初始值为t
		- 容器操作可能使迭代器失效
			- 不要保存end返回的迭代器
				- 在循环中删除或添加元素导致迭代器失效后 用end判定循环的代码行为是未定义的 会引发无限循环
				- 保证每次判断时都使用更新的end迭代器
	- vector对象是如何增长的
		- 部分接口显示出分配空间
			- c.shrink_to_fit()
				- 要求deque vector string退回不需要的内存空间
				- 只是代表我们表示不再需要更多的内存空间
				- 不代表一定会退回内存空间
				- 将capacity()减少为size()大小
				- c.resize(c.size())? no resize只改变容器中元素的数量 不改变容器的capacity
			- c.capacity() 不重新分配内存时可以存放多少个元素
			- c.reserve(n) 
				- 分配至少能存n个元素的内存空间
				- 只有当需求超过当前capacity时才会重新分配内存 分配的内存至少满足需求 可能更大
				- 永远不会减少容器占用的内存空间
	- 额外的string操作
		- 构造string的其他方法
			- string s(cp,n)
			- string s(s2,pos2)
			- string s(s2,pos2,len2)
		- substr
			- s.substr(pos,n)
			- s.substr(pos) b > e raise out_of_range_error
		- 改变string的其他方法
			- 查表型 需要时回来翻看即可
			- replace
			- append
			- insert
			- find
			- rfind
			- find_first_of
			- find_last_of
			- find_lirst_not_of
			- find_last_not_of
			- compare
			- to_string()
			- stoi(s,p,b)
			- stof(s,p)
			- stod(s,p)
			- sto...
	- 容器适配器
		- 序列式容器适配器
			- stack
			- queue
			- priority_queue
		- 定义适配器
			- 默认构造
			- 拷贝构造
			- 所有适配器都需要容器有添加 删除 访问尾元素的能力 所以array forward_list容器类型完全不可以作为第二参数来重载默认容器
				- stack 要求back 所以其他序列式容器都可重载 默认是deque
				- queue 还要push front 所以 list和deque可 vector不可
				- priority_queue 不要push front 但要随机访问 所以 vector和deque可 list不可
- 第十章 泛型算法
	- 概述
		- 算法一般通过迭代器范围操作容器 迭代器令算法不依赖于容器 但算法依赖于元素类型的操作
		- 算法不改变底层容器的大小 它可能改变元素的值 也可能在容器内移动元素 但不会添加或删除元素
	- 初识
		- 只读
			- 仅接受单一迭代器来表示第二个序列的算法 都假定第二个序列至少和第一个一样长
		- 写
			- 容器大小要满足算法能写入需要写入的元素 大小指元素个数而不是可用空间
			- 算法不检查写操作
			- 由于以上两点 引入 插入迭代器 insert_iterator 插入赋值号右值元素到容器中
		- 重排
	- 定制操作
		- 向算法传递函数 
			- predicate 谓词
				- 一元谓词
				- 二元谓词
			- lambda函数
				- [capture list](parameter list) -> return type {function body}
				- capture list lambda函数定义的局部变量列表 通常为空
				- 捕获
					- 值捕获
						- 捕获的值在lambda创建时拷贝得到 在正式调用lambda前 原值的更改不会影响到lambda拿到的拷贝值
						- 非指针类型可以直接 值捕获
					- 引用捕获
						- 比如 ostream& 无法拷贝值 只能引用
						- 原则
							- 首先要确保lambda创建时对象是存在的
							- 从创建到调用lambda函数期间 对象的值可能做出过改变 是否仍是期望值
							- 可能的话 尽量减少引用捕获
					- 隐式捕获
						- 值捕获 [=]
						- 引用捕获 [&]
						- 混用
							- [=,...]
							- [&,...]
					- 可变lambda
						- mutable 如果一个lambda是值拷贝返回一个++int 那使用mutable可以在重复调用lambda时更新返回的int值 否则重复调用也只能无限++一次 由于是值拷贝 原值无论如何不受影响
						- 引用捕获也可以做到上述效果 原值也会改变
			- 参数绑定
				- bind
					- 占位符
						- void Foo(arg1,arg2);
							bind(Foo,_1,arg2);
					- 绑定引用参数 ref(param) cref(param)	
						- lambda中捕获引用型参数 比如ostream& os
							ostream& print(ostream& os, const string& s, char c);
							bind(print,ref(os),_1,arg2);
	- 再探迭代器
		- 插入迭代器
		- 流迭代器
		- 反向迭代器
		- 移动迭代器
	- 泛型算法结构
		- 5类迭代器
			- 输入迭代器 只读不写 单遍扫描 只能递增 
				- == ！=
				- ++
				- * 解引用只出现在等号右边 *iter++ 总是有效的
				- ->
			- 输出迭代器 只写不读 单遍扫描 只能递增 
				- ++
				- * 解引用只出现在等号左边
			- 前向迭代器 可读写 多遍扫描 只能递增
			- 双向迭代器 可读写 多遍扫描 可递增递减
				- --
			- 随机访问迭代器 可读写 多遍扫描 支持全部迭代器运算
				- < <= > >=
				- + += - -=
				- -
				- []
		- 算法形参模式
			- alg(beg,end,...)
			- alg(beg,end,dest,...) 要求dest迭代器的算法都默认无论写入多少数据目标空间都可容纳 一般是插入迭代器或ostream_ieterator
			- alg(beg,end,beg2,...) 比如transform beg2也可以是beg1原址改造
			- alg(beg,end,beg2,end2,...)
		- 算法命名规范
			- 一些算法通过重载形式传递一个谓词
				- unique(beg,end)
				- unique(beg,end,comp)
			- _if版本
				- find(beg,end,val)
				- find(beg,end,pred)
			- _copy版本
	- 特定容器算法
		- 链表类型 
			- 修改指针而非元素缩短时间
				- lst.merge(lst2)
				- lst.merge(lst2,comp)
				- lst.remove(val)
				- lst.remove_if(pred)
				- lst.reverse()
				- lst.sort()
				- lst.sort(comp)
				- lst.unique()
				- lst.unique(pred)
			- splice成员 剪切lst2元素到lst p后位置
				- lst.splice(args) or flst.splice_after(args)
					- (p,lst2)
					- (p,lst2,p2)
					- (p,lst2,b,e)
- 第十一章 关联容器
	- 类型
		- 按关键字有序保存元素 使用比较运算符来组织元素
			- map 	键值对
			- set 	关键字
			- multimap	关键字可重复的map
			- multiset	关键字可重复的set
		- 无序集合 hash实现
			- unordered_map
			- unordered_set
			- unordered_multimap
			- unordered_multiset
	- 使用关联容器
		- map
			- 关联数组map就是下标不必是整数的数组
			- item.first item.second
		- set
			- item_set[key] = value
	- 概述
		- 定义关联式容器
			- 不支持push_back() push_front() 使用insert()
			- 关联式容器都是双向迭代器类型
		- 关键字类型的要求
			- 元素类型必须定义元素比较的方法 毕竟是对key先排序再放入 排序标准就是使用元素定义方法 这点和算法是一样的
			- 如果元素未提供 和算法一样 支持输入一个谓词来比大小
			- 谓词比大小遵循  严格弱序
				- if k1 <= k2 && k2 <= k1 {k1 = k2}
				- if k1 <= k2 && k2 <= k3 {k1 <= k3}
			- multiset<key,comp>
				- multiset<my_class_type,decltype(my_comp)*>
		- pair类型
			- 头文件utility
			- 默认构造函数会对其成员默认值初始化
			- 也可以使用拷贝构造给值
			- 返回值为pair的函数可以在条件语句中返回默认构造或者{}拷贝构造
			
			- 操作
				- pair<T1,T2> p;
				- pair<T1,T2> P(v1,v2);
				- pair<T1,T2> p = {v1,v2};
				- .first .second
				- make_pair(v1,v2);
				- == !=
				- < <= > >= 字典序
	- 操作
		- 类型别名 map<T1,T2>
			- key_type 		T1				set类型的key_type和value_type是一样的
			- mapped_type 	T2 				只有map类型有
			- value_type	pair<T1,T2>		解引用一个关联式容器迭代器时 得到一个value_type的值引用
		- 关联式容器迭代器
			- key_value是const的
			- map_it -> first, map_it -> second
			- 通常不对关联式容器使用泛型算法 因为key_value const特性很难用来算法遍历，改值和重排
			- 但关联式容器特化了一些算法 比泛型算法更快 更适合这个容器
		- 添加元素
			- 操作
				- c.insert(v);
				- c.emplace(args);
				- c.insert(b,e);
				- c.insert({});
				- c.insert(p,v);
				- c.emplace(p,args);
			- 返回值
				- pair<p,bool> first 指向value_type second 元素插入成功or已存在
		- 删除元素
			- c.erase(k); 	返回size_type 指出删除的元素数量
			- c.erase(p);	返回p之后元素的迭代器 未找到返回c.end()
			- c.erase(b,e);	返回e
		- map下标
			- 与vector不同 找不到map[key]时会添加key到map 序列式容器下标不越界是程序员的责任
			- 操作
				- c[k]		适用于非const的map和unordered_map
				- c.at(k)
		- 访问元素
			- c.find(k);			检查元素是否在map容器中可以用find()代替下标操作
			- c.count(k);			multimap/multiset中查找遍历所有key的mapped_value可以使用 count() + find()
			- c.lower_bound(k);		不适用于无序容器 multimap/multiset中查找遍历所有key的mapped_value也可以使用该迭代器
			- c.upper_bound(k);		如果lower_bound()和upper_bound()返回相同的迭代器 即 c.end() 那给定关键字不在容器中
			- c.equal_range(k);		最直接的方法 返回一个pair<first_match_it,last_match_it>
	- 无序容器
		- 概要
			- 哈希函数实现
			- 在某些场景下 维护元素序代价高昂 无序容器是有必要的
			- 理论上哈希实现可以获得更好的平均性能 但需要性能测试和调优
		- 操作
			- 桶管理
				- 桶接口
					- c.bucket_count()		正在使用的桶的数目
					- c.max_bucket_count()
					- c.bucket_size(n)		第n个桶中有多少元素
					- c.bucket(k)			关键字为k的元素在哪个桶中
				- 桶迭代
					- local_iterator
					- const_local_iterator
					- c.begin(n) c.end(n)	桶n的首尾元素迭代器 返回local_iterator
					- c.cbegin(n) c.cend(n) 返回const_local_iterator
				- 哈希策略
					- c.local_factor()		每个桶的平均元素数量 返回float
					- c.max_load_factor()	local_factor <= max_local_factor
											bucket_count >=n
											bucket_count > size/max_load_factor
					- c.rehash(n)
					- c.reserve(n)	
		- 对关键字的要求
			- 自定义类型的关键字需要自己提供哈希重载作为参数传到哈希模板
				- ==
				- hasher函数重载		
- 第十二章 动态内存
	- 动态内存与智能指针
		- 介绍
			- new 在动态内存空间堆中为对象分配一个空间并返回一个指向该对象的指针
			- delete 接受一个动态对象的指针 销毁该对象 并释放与之关联的内存 忘记释放内存会导致内存泄漏
			- 标准库提供管理动态内存的智能指针 头文件 memory
		- 操作
			- shared_ptr与unique_ptr共有操作
				- shared_ptr<string> sp;
				- unique_ptr<string> up;
				- p 						if p 当p指向一个对象时为true if p->empty() 若p1指向类型的对象值为空
				- *p 						解引用p 获得它指向的对象
				- p -> mem 					等价于 (*p).mem
				- p.get()					返回p中所保存的指针 若p已释放其对象 则返回的指针指向的对象已经消失
				- swap(p,q)					交换指针 
				- p.swap(q)					其实.reset()就是调用了p.swap(q) 交换指针
			- shared_ptr
				- make_shared<T>(args) 		返回一个shared_ptr 指向一个动态分配的T类型的对象 用args初始化对象
				- shared_ptr<T> p(q)		p是shared_ptr指针q的拷贝 会递增q的计数器
				- p = q 					p和q都是shared_ptr 递减p的计数器并递增q的计数器 若p的引用计数变为0 则将其管理的原内存释放
				- p.unique() 				若p.unique()=1 返回true 否则false
				- p.use_count() 			返回与p共享对象的智能指针数量 可能很慢 主要用于调试
		- shared_ptr
			- 构造
				- make_shared函数 是最安全的分配和使用动态内存的方法 类似序列式容器的emplace成员 安全构造 一般可以用auto保存其指针类型
				- 来自互联网：
					make_shared安全在于：
						防止使用相同的内置指针值初始化（或reset）多个智能指针 及其导致的同一个对象被多次销毁的潜在问题 
						new一个对象并赋给shared_ptr 是分两步 
						先分配对象内存 
						再分配一个控制块内存 
						同一个动态对象被多个shared_ptr持有 
						意味着一个动态对象 多个控制块内存 
						其引用计数是分开的
						会使shared_ptr原本的设计目的失效
						而且离开作用域时
						同一个对象被销毁两次会出事
						but make_shared在分配对象内存时就同时在临近的内存分配了一个控制块
						所有后来的shared_ptr拷贝或赋值都记录在这个控制块之下
						可以起到shared_ptr统计对象持有数的作用
					make_shared劣势：
						还是控制块的问题
						weak_ptr的设计是
						当最后一个弱引用离开的时候 共享的内部信息控制块才会被销毁和释放
						这意味着
						使用make_shared构造的动态对象
						生命周期并不是shared_ptr决定的
						最后一个weak_ptr销毁时 动态对象才会被销毁
						无形中延长了其生命周期
				- 来自自己：
					注意make_shared是用于构造 构造 构造

					由于shared_ptr支持拷贝构造和拷贝赋值
					make_shared作为右值可以帮助构造shared_ptr

					作为右值就意味着
					如果make_shared封装在一个函数里
					它必须有返回值

					如果没有返回值的话
					由于make_shared对象和shared_ptr已经绑定
					一荣俱荣 一损俱损
					离开作用域时 不管局部作用域拷贝了多少个shared_ptr都会自动销毁
					make_shared动态对象也就销毁了

					也因为make_shared仅用于构造shared_ptr
					因此一个已经存在的智能指针
					哪怕是一个已经存在的空智能指针
					只能通过p1.reset(p2) 即 p1.swap(p2)的方式交换指针 重设动态对象的控制权

			- 拷贝构造和拷贝赋值
				- 共享一份在动态内存空间上的数据 每个shared_ptr都有一个关联的计数器 引用计数 reference_count
			- 自动释放对象和内存
				- reference_count = 0 时会自动调用析构函数释放其管理的对象
				- 确保无用的shared_ptr手动销毁 如果将指针保存在容器中并进行了重排 确保重排后erase掉不需要的元素 否则内存泄漏
			- 使用动态内存的三种原因：
				- 程序不知道自己需要使用多少对象	容器
				- 程序不知道所需对象的准确类型	十五章举例
				- 程序需要在多个对象间共享数据	本章举例
		- 直接管理内存
			- new
				- auto 
					- 智能指针的类型 如果new的对象初始化时使用单个初始化器 可以用auto推测类型
					- auto p1 = new auto(obj) 	可
					- auto p2 = new auto{a,bc} 	不可
				- const
				- nothrow
					- bad_alloc
						- 内存不够时无法new一个空间 抛出异常bad_alloc
					- 不想抛出异常时用 new (nothrow) obj 定位new 返回一个空指针
			- delete
				- 必须传一个指向动态对象的指针或一个空指针
				- 销毁给定指针指向的对象 并 释放对应的内存
				- 释放一块非new分配的内存 或者相同的指针释放多次 其行为是未定义的
				- 动态对象的生存期直到它被销毁为止 使用非智能指针处理动态对象时需要手动管理对象的生存期 显示释放前一直会存在
					- 也就是说 在函数体中使用到的指针 都要看看它指向的对象是否是动态对象 然后决定是在函数体处理掉 还是交给程序调用者决定
			- 使用new delete管理动态内存存在3个问题：
				- 忘记delete 内存 导致内存泄漏
				- 使用已经释放掉的对象 有时可以检测出这种错误
				- 同一块内存释放两次
				- 以上 希望大家坚持使用智能指针
			- dangling pointer 空悬指针
				- 指针所指对象已销毁 但指针依然指向其地址
				- 未初始化指针的所有缺点 空悬指针都有
				- 离开作用域前 释放掉指针关联的内存 delete之后 将nullptr赋予指针 清楚地指出该指针不再指向任何对象 然后指针离开作用域
				- 但这不解决多个指针指向同一个对象的问题
		- shared_ptr和new结合使用
			- 智能指针的构造函数是explicit的 不能通过拷贝赋值的方式构造 只能拷贝构造创建
				- shared_ptr<int> p1 = new int(1024) 	不可
				- shared_ptr<int> p1(new int(1024))		可
			- 函数体的return和返回值都显示要求智能指针型
			- 其他操作
				- shared_ptr<T> p(q);					p管理内置指针q所指向的对象
				- shared_ptr<T> p(u); 					从unique_ptr接管对象的所有权
				- shared_ptr<T> p(q,d); 				传入自定义的delete操作
				- shared_ptr<T> p(p2,d);				p是p2的拷贝 区别是p使用自定义的delete操作
				- p.reset();							若p是唯一指向该动态对象的智能指针 释放对象 将p置为空
				- p.reset(q);							令p指向q或空 经常和unique一起使用 判断是否是唯一用户 不是的话先拷贝数据再改值
				- p.reset(q,d);							释放q时调用d
			- 不要混合使用智能指针和普通指针
				- 使用普通指针访问智能指针负责的对象很危险 因为你不知道对象何时会被销毁
			- 永远不要用p.get()初始化另一个智能指针或为智能指针赋值
				- p.get()返回一个内置指针 设计场景是 向不能使用智能指针的代码传递一个内置指针 但这段代码不能delete内置指针
		- 智能指针和异常
			- 如果是普通指针 在new和delete之间出现未捕获的异常 会引起内存泄漏
			- 分配内存 但没有写析构函数来销毁内存的自定义类 使用智能指针可以有效解决以上问题
			- deleter删除器
			- 智能指针基本规范
				- 不使用相同的内置指针值初始化（或reset）多个智能指针 （注：原因见上文shared_ptr构造-来自互联网）
				- 不delete get()返回的普通指针 （注：避免发生第三条也就是第一条的惨案以及第四条）
				- 不使用get()初始化或reset另一个智能指针 （注：这和第一条使用相同的内置指针初始化多个智能指针是一样的风险）
				- 如果你使用get()返回的普通指针 记住当最后一个智能指针销毁后 该指针也无效了 （注：这违背了智能指针的设计目的）
				- 如果智能指针管理的资源不是new分配的内存 记住传一个删除器
		- unique_ptr
			- 初始化必须采用直接初始化形式 绑定到一个new返回的指针上
			- 不支持拷贝构造和拷贝赋值
			- 支持转移所有权
				- unique_ptr<string> p2(p1.release());	转移p1所有权到p2 p1置空
				- p2.reset(p3.release());				释放p2原动态对象 转移p3所有权到p2 p3置空
				- 这两个用法是推荐的使用.release()的方法 否则要么丢了指针，要么指针传给普通指针 还需要手动delete *p
			- 操作
				- unique_ptr<T> u1;						空unique_ptr 使用delete释放指针
				- unique_ptr<T,D> u2;					使用可调用对象D释放指针
				- unique_ptr<T,D> u(d);					用类型为D的对象d代替delete
				- u = nullptr;							释放u指向的对象 并将u置为空
				- u.release();							u放弃对指针的控制权 返回指针 并将u置为空
				- u.reset();							释放u指向的对象
				- u.reset(q);							令u指向q或空
				- u.reset(nullptr);						等价于u = nullptr;
		- weak_ptr
			- 不控制所指对象的生命周期的智能指针 指向一个shared_ptr指向的动态对象
			- 将一个weak_ptr绑定到shared_ptr上不会增加shared_ptr的引用计数
			- 最后一个指向对象的shared_ptr被销毁 对象就会被释放 即使有weak_ptr指向对象
			- 来自互联网：当最后一个弱引用离开的时候, 共享的内部信息控制块会被销毁和释放(共享的对象也会被释放, 如果还没有释放的话)
				which means make_shared
			- 操作
				- weak_ptr<T> w;						空weak_ptr
				- weak_ptr<T> w(sp);					指向shared_ptr指向的对象
				- w = p;								p可以是shared_ptr或weak_ptr w与p共享对象
				- w.reset();							将w置空
				- w.use_count();						与w共享的shared_ptr的数量
				- w.expired();							若w.use_count()为0 返回true 否则false
				- w.lock();								如果expired返回true 返回一个空shared_ptr 否则返回对象的shared_ptr
			- 用途
				- if条件判断w.lock()存在后在if作用域内安全共享对象
				- 不影响对象的生命周期 但可以安全访问对象
	- 动态数组
		- new和数组
			- 动态分配一个空数组是合法的
			- unique_ptr操作
				- unique_ptr<int[]> up(new int[10]);	
				- up.release() 							会自动调用delete []
				- up[i]									当一个up指向数组时 不能使用.和->运算符 但可以使用[]访问数组中的每个元素
				- delete[] p 							释放动态数组 p指向的还是动态数组的首元素
			- shared_ptr不直接支持管理动态数组 需自定义deleter 可以用lambda函数
				- shared_ptr<int> sp(new int[10],[](int* p)->{return delete[] p;});
				- sp.reset();
		- allocator类
			- 头文件memory
			- 将内存分配和对象构造分开来
			- 操作
				- allocator<T> a;						定义一个名为a的allocator对象 可以用于分配内存
				- a.allocate(n);						使用allocator对象a 分配原始的 未构造的n个类型为T的对象的空间 返回p指针
				- a.deallocate(p,n);					p必须是一个先前allocate返回的指针 n必须是创建时要求的大小
				- a.construct(p,args);					p指向的原始内存 args传递给类型为T的构造函数来构造对象
				- a.destroy(p);							对p指向的对象执行析构函数
			- 伴随算法
				- uninitilized_copy(b,e,b2);			从一个迭代器范围拷贝到原始内存 返回q指针 最后构造的元素之后的位置
				- uninitilized_copy(b,n,b2);			从迭代器首元素开始 拷贝n个元素到原始内存
				- uninitilized_fill(b,e,t);				在原始内存迭代器范围内创建对象 值为t的拷贝
				- uninitilized_fill(b,n,t);				在原始内存迭代器首元素起 创建n个 值为t的拷贝
	- 使用标准库：文本查询程序
		- 设计
			- 列出程序的操作帮助我们确定合适的数据结构
				- 容器选择
				- 类 功能 数据共享
				- 设计一个类时 真正实现成员之前先编写如何使用这个类
			- 来自自己：
				- 针对这个需求 为什么不能使用一个类解决问题？为什么需要两个类？
					- 接口固定
						由于使用者的代码要求print(cout,ts.query(s))这样的使用接口已经固定了 只能这么写
						那就需要ts.query(s)返回一个类 
						因为函数接收两个及以上返回值比较麻烦 额外的返回值需要传引用 比较曲折 传一个类会很清晰方便
						但会需要考虑多个类共享数据的问题

						换句话说 接口变了 比如 tq.query(s) tq.query_file(file)这样的接口
						那就不需要用到两个类 一个类可以搞定 也无需考虑多个类共享数据的问题
						见text_query_simple.h

						而事实上 接口固定再实现的情况比较多 大概
						所以必须习惯起来
				- 为什么需要先封装str_blob类和str_blob_ptr类？
					- 其实不用 这里主要是为了教学 学习目标可以说是 
						- 学会分离式编译
							- ld: symbol(s) not found for architecture x86_64 一般是头文件引入错误
								实测分离式编译.cpp文件都引.cpp不容易出错 否则根据提示检查
							- .h头文件中 接口声明的返回类型是没有出现过的指针类 需要先前置声明 不需要引入指针类的头文件
							- .h头文件中 需要用到其他类的具体对象 而非指针或引用时 比如用于构造函数传参 取其数据来构造时 需要引入头文件
						- 学会写一个带指针的类
						- 学会写一个简易迭代器（还是一个带指针的类）
							- 构造函数
								- 传参可以有const版本和非const版本
								- 看具体使用情况可以增加构造函数
								- 拷贝赋值 拷贝构造 析构函数 big three
							- 接口函数
								- 需要使用到其他类的具体操作时 应该在其他类的.cpp文件 也就是其他类的定义之后实现接口定义
								- 局部变量的返回值不能是引用
								- 需要修改原值时返回值必须是引用 尤其是拷贝赋值
								- 函数名最好能看得出函数是否改变类的数据 如果不改变一定要加const 共享数据 
									连续调用时发现某一环不是const再去改就还挺麻烦
									- 常见错误
										the object has type qualifiers that are not compatible with the member function "Str_blob::at" -- object type is: const Text_query_blob::str_blob
							- private区的数据可以是一个函数的返回对象
							- 学会写操作符重载的替代函数
								- ++ * 是成员函数
								- 比大小 == != 是友元函数
									- == 回顾两个迭代器相等的条件：
										- 要么都是空智能指针 都不指向任何对象
										- 要么指向同一个对象的同一个位置
						- 学会使用shared_ptr共享数据
							- 智能指针的构造函数是explicit的 只能拷贝构造不能拷贝赋值
								- shared_ptr和new结合使用
									- 只能拷贝构造
								- make_shared构造函数
									- 只能构造
						- 学会使用weak_ptr检查对象是否存在
							- .lock()返回shared_ptr再判断
						- 学会使用std::size_t类型 
							size_t是标准库定义的类型 
							在不同的机器上自动调节大小 unsigned long || unsigned long long etc.
						- 学会使用static
						- 学会使用标准库提供的算法
						解法见text_query_blob.h


						这里str_blob类相当于vector<string>的适配器
						封装了vector<string>并开放了一些vector<string>的方法
						其中一些方法需要用到迭代器
						因此需要再写一个str_blob_ptr类提供迭代器操作
						我猜后续章节应该可以有不同层面的解法

						在text_query类使用自定义封装类和使用stl容器类没有不同
						抛开以上学习目标
						用using也能起到封装效果
						顺便把shared_ptr也封装进去都很方便
						见text_query_b.h
- 第十三章 拷贝控制
	- 介绍
		- 实现拷贝控制最困难的地方在于认识到什么时候需要定义这些操作
	- 拷贝 赋值与销毁
		- 拷贝构造
			- 合成拷贝构造函数 
				- 注：根据侯捷老师：带指针的类需要自己写 
					防止浅拷贝引起的问题 比如拷贝时对指针的拷贝希望是新增一个指向对象的指针 而不是拷贝指针本身
			- 拷贝初始化
				- 在以下情况下发生：
					- =
					- 将一个对象作为实参传递给一个非引用类型的形参
					- 从一个返回类型为非引用类型的函数返回一个对象
					- 从{}列表初始化一个数组中的元素或一个聚类中的成员
					- 某些类类型的成员函数
						- insert push 拷贝初始化 （拷贝赋值）
						- emplace 直接初始化 （拷贝构造）
			- 参数和返回值
				- 拷贝构造函数被用来初始化 非引用类 类型参数
					其参数必须是引用类型
					因为调用拷贝构造函数必须拷贝它的实参 但拷贝实参又必须用到拷贝构造函数
					不使用引用类型 则调用永远在循环中 不会调用成功
			- 拷贝初始化的限制
				- explicit 如果直接初始化被定义为explicit 会限制拷贝构造
			- 编译器可以绕过拷贝构造
				- 编译器可以（但不是必须）将代码改写为直接初始化的形式（但拷贝/移动构造函数必须是存在且可访问的）
		- 拷贝赋值
			- 重载赋值运算符
				- 为了与内置类型的赋值保持一致 赋值运算符通常返回一个左值引用
				- 赋值运算符通常应该返回一个左值引用
			- 合成拷贝赋值
				- 注意点同上
		- 析构函数
			- 与构造函数操作相反
				- 构造函数 初始化对象的非static数据成员
				- 析构函数 释放对象使用的资源 并销毁对象的非static数据成员
			- 语法
				- ~ 不接受参数 没有返回值
				- 由于不接受参数 因此析构函数不接受重载 一个给定类有且仅有一个析构函数
			- 何时会调用析构函数
				- 无论何时一个对象被销毁 就会自动调用其析构函数
					- 离开作用域时被销毁
					- 当一个对象被销毁时 其成员被销毁
					- 容器被销毁时 其元素被销毁
					- 动态分配的对象 当delete其指针时被销毁
					- 临时对象 表达式创建结束即销毁
			- 合成析构函数
				- 注意点同上
		- 三五法则
			- big three
				- 带指针的类 动态分配内存的类 拷贝构造 拷贝赋值 析构函数不可少
				- 需要析构函数的类也需要拷贝构造和拷贝赋值
					- 参见合成拷贝构造和拷贝赋值注意点
				- 需要拷贝构造的类也需要拷贝赋值 反之亦然
					- 传值会调用拷贝构造
			- big five
				- 移动构造
				- 移动赋值
		- 使用 =default
			- 显式要求编译器采用合成版本
			- 只能对有合成版本的成员函数采用=default
		- 阻止拷贝 =delete
			- 定义删除的函数
				- 通知编译器和代码读者 虽然声明了这个函数 但不能以任何方式使用
			- 析构函数不能是删除的成员
				- 一个声明了删除析构函数的类 编译器将不允许定义该类的变量或创建该类的临时对象
				- 一个类的成员声明了删除析构函数 编译器也不允许定义该类的变量或创建该类的临时对象
			- 合成的拷贝控制成员可能是删除的
				- 查表型
				- 本质上 当不可能拷贝 赋值或销毁类的成员时 类的合成拷贝控制成员就人为定义为删除的
					如果没有这条规则 可能会创建出无法被删除的对象 这不行
			- private拷贝控制
				- 新标准发布前的方案 现在用=delete
	- 拷贝控制和资源管理
		- 行为像值的类
			- 拷贝值 副本和原对象是完全独立的 改变副本不会对原对象有任何影响 反之亦然
				- eg. string类
			- 防范自赋值
				- 先判断拷贝赋值的对象是否即自身 否则delete指针时就把自身的成员删除了 
					试图拷贝其值时 就会试图解引用一个指向无效位置的指针 未定义的行为
		- 行为像指针的类
			- 拷贝地址 底层数据相同 改变副本也会改变原对象 反之亦然
				- eg. Str_blob类
			- 引用计数
				- 直接初始化时引用计数设为1
				- 拷贝构造时增加引用次数1
				- 拷贝赋值时增加右侧引用计数 减少左侧引用计数 左侧引用计数减少为0时 销毁左侧对象 将右值拷贝给左值 返回左值引用
		- 行为不像值也不像指针的类
			- eg. unique_ptr 不允许拷贝或赋值
	- 交换操作 swap
		- 一个类定义了自己的swap 算法将使用自定义版本 否则使用标准库定义版本（值拷贝而非指针拷贝）
		- 交换值/指针 就像三元交换变量 一次拷贝 两次赋值
			- 来自自己：
				- void swap(T& a, T& b) {
					T tmp(a);
					a = b;
					b = tmp;
				}
				- void swap(T& a, T& b) {
					T tmp(std::move(a));
					a = std::move(b);
					b = std::move(tmp);
				}
		- swap函数应该调用swap 而不是std::swap
			- 如果函数内部希望调用自身 而不是std::swap
				可以显式地告诉编译器 当我想要使用std::swap时 我会跟你说它叫std::swap 否则我说的就是我的swap
				using std::swap; //显式声明std::swap
				my_swap(a.v,b.v); //使用自己版本的swap
		- 在赋值运算中使用swap
			- 将左值与右值的副本交换
			- 自动处理了自赋值的情况
			- 唯一可能抛出异常的地方是new表达式 但即使抛出异常 也是在赋值前发生
			- 在拷贝和赋值的逻辑中需要循环遍历操作的话 用swap不太合适 效率更低
	- 拷贝控制示例
		- 明确是值拷贝还是指针拷贝
		- 明确拷贝构造和拷贝赋值的逻辑
			- 是否选择swap处理拷贝赋值
		- 明确析构函数的逻辑
	- 动态内存管理类
		- 介绍
			- 某些类在运行时需要分配可变大小的内存空间 能用标准库容器的时候应该用标准库
				某些类需要自己进行内存分配 那就要定义自己的拷贝构造和拷贝赋值来管理分配的内存
			- 移动构造函数 move
			- 来自自己：
				- 报错
					- member declaration does not match because it is not const qualified
						- 可能是成员函数const的问题
					- forward declaration of ''
						- main.cpp文件的头文件引入问题
					- free中逐一销毁元素使用for_each和lambda有何不同？
						- 无需移动指针 费心指针增减控制
				- 拷贝构造
					- 拷贝操作都会用到的共有操作会封装成私有成员函数
					- auto dest_first = a.allocate(e-b) 
						- 返回新分配内存（大小为e-b 类型为指针数据类型）的首元素地址
					- auto next_first = uninitialized_copy(b,e,dest_first) 
						- 拷贝从b到e元素到未初始化的 新分配的内存 返回尾后元素地址 
							其实内部调用的还是construct 
							construct调用的就是new一个对象
						- 相比construct好处是不需要自己写循环和后++
					- a.construct(p,args) 在已分配内存上构造对象 无返回值
					- 我想需要循环构造就用uninitialized_copy 构造一个元素就用construct 后++
				- 析构函数
					- 就像拷贝操作都会用到的共有操作会封装成私有成员函数一样
						拷贝赋值和销毁类都需要用到的析构操作 可以封装一个私有成员函数free()
					- a.destroy(p) 相对于a.construct() 用于析构单个指针指向的对象
						但没有一个封装处理多个元素的destroy 就用for_each + lambda写一下
						for_each(elements,first_free,[](string& s)->void{a.destroy(&s);});
					- a.deallocate(p,n) 借的时候要多少内存 会返回一个首元素指针（借的凭证） 还的时候你要拿着凭证和还多少一起还
				- 剧透：
					- 实现一个简易vector仅需要3根指针
					- 实现一个简易string仅需要1根指针
	- 对象移动
		- 介绍
			- 新标准
				- 标准库容器 string shared_ptr 	可以移动 		  可以拷贝
				- io类 unique_ptr类	 			可以移动		不可以拷贝
		- 右值引用 &&
			- 接管资源
			- 右值引用很短暂 只能绑定到一个临时对象 一个将要销毁的对象 该对象没有其他用户 将资源移动到另一个对象
			- 左值持久 右值短暂
				- 变量是左值 不能将一个右值引用绑定到左值 即使左值是一个右值引用类型
				- 左值引用举例：
					- 返回左值引用的函数
					- 赋值
					- 下标
					- 解引用
					- 前置递增递减运算符
				- 右值引用举例（和左值引用完全相反）：
					- 返回非引用类型的函数
					- 算数
					- 关系
					- 位
					- 后置递增递减运算符
				- 来自自己：
					- 左值 重要的 关心的 谨慎的 即使是常值引用 也会先拷贝一份地址 长久的
					- 右值 不重要的 不关心的 无所谓的 临时的 孤单的 没有其他对象的 可以随意更改的 掏空后置空已经是最大的仁慈
			- 标准库move函数
				- 使用std::move()表示我们有一个左值 但希望像右值一样处理它
				- 调用std::move(rr1)意味着 除了对rr1赋值或销毁 我们将不再使用它
		- 移动构造函数和移动赋值运算符
			- noexcept 通知（承诺）标准库我们的构造函数不会抛出异常 （我说可以就可以）
				- 编写一个不会抛出异常的移动操作（移动构造和移动赋值）时（不分配任何新内存）应该通知标准库
					否则标准库认为它随时可能会抛出异常 因此会做一些额外的工作
			- 语法上出现在构造函数的参数列表之后 :之前
				- 移后原对象必须可析构
					- 但用户不能对其值有任何假设
			- 合成的移动操作
				- 如果一个类定义了自己的big three 编译器就不会为它合成移动构造函数和移动赋值函数了
				- 只有一个类没有定义任何版本的拷贝控制函数 且类的每一个非static数据成员都可以移动时 编译器才会提供合成移动构造和合成移动赋值
					如果一个成员是类类型 且该类有对应的移动操作 编译器也能移动这个成员
				- 合成的移动操作永远不会隐式定义为删除的函数
					- 但如果显示要求移动构造函数=default 且编译器不能移动所有成员 移动操作被定义为删除的 eg.无法调用std::move()
					- 原则：查表型
					- 定义一个移动构造和移动赋值的类也必须定义拷贝操作 否则拷贝操作默认被定义为删除的
						（要么big three 要么big five)
			- 移动右值 拷贝左值
				- 等号可以表示两件事了 移动和赋值
				- Str_vec v1,v2;
					v1 = v2; //拷贝赋值 变量是左值
					Str_vec get_str_vec(istream& in);
					v2 = get_str_vec(cin); 
					//移动赋值 右值是返回非引用类型的函数 
					其实移动和拷贝都符合调用条件 拷贝会增加一次const转换 移动时精确匹配 此时使用移动赋值
			- 如果没有移动构造函数 右值也被拷贝
				- 一个类只有big three没有big five就会用拷贝构造 不会有什么合成移动操作 原因如上
			- 拷贝并交换赋值运算符和移动操作
				- hp = std::move(hp2);
					- 单一赋值运算符实现拷贝赋值和移动赋值两种功能
					std::move()将一个右值引用绑定到hp2 此时移动赋值函数是精确匹配
				- 如果一个类定义了任何一个拷贝操作 就应该定义全部big five
			- 移动迭代器
				- move_iterator解引用是一个右值引用
				- make_move_iterator将一个普通迭代器转化为移动迭代器
				- alloc.construct()接受右值引用会调用元素的移动构造而非拷贝构造 更快
				- uninitialized_copy(b,e,first) 的first是右值引用对每个元素调用construct
				- 建议小心使用move 确保移后源对象没有其他用户
				- 为什么unique_ptr不允许拷贝操作 但在函数中返回unique_ptr的值是合法的？
					- 因为unqiue_ptr支持移动操作 调用了移动构造
			- 来自自己：
				- 移动操作和拷贝操作实现的不同：
					- 移动操作需要声明noexcept
					- 拷贝需要分配内存 移动不需要
					- 移动需要安全析构右值 拷贝不需要
					- 移动可以额外采用移动迭代器处理元素
				- 相同点：
					- 赋值都要自赋值检测
					- 赋值都要先处理左边
		- 右值引用和成员函数
			- 侯捷老师有讲 函数const与否和参数const与否的一个表格
				函数const配参数const
				函数非const配函数非const
				这样两个就够用

				这边类比的话
				我觉得是在讲
				参数也有常值引用（左） 非常值引用（左） 右值引用 常值右值引用 4种情况
				但是两种就够了 也就是常值引用和右值引用
				这也可以用来区分移动和拷贝重载
				调用时根据实参类型自动调用符合的函数
				T v();
				push_back(v); //调用就会是拷贝构造
				push_back(T()); //调用就会是移动构造
				想要有这种性能上的提升就要写移动构造函数
			- 右值和左值引用成员函数
				- 引用限定符 & && 
					- 像const一样修饰函数 指出this指向左值或右值
					- 只能用于非static成员函数
					- 必须同时出现在声明和定义中
					- & 只能指向左值
					- && 只能指向右值
					- 一个函数可以同时用const和引用限定 引用限定符紧跟const
					- 一个返回值的函数 使用引用限定符 限定函数表达式返回的值是左值还是右值 
						（表达式的结果能否出现在等式左边 或能否当右值对待）
				- 重载和引用函数
					- 可以根据引用限定符区分重载函数的 就像const
					- 对象是一个右值 意味着没有其他用户 因此可以改变对象
					- 当对一个左值进行操作的时候 由于不能改变 总是要先拷贝一份
					- 如果定义了两个版本 其中一个写了引用限定符 另一个也要写 要么就两个都不写
						- && / const &
						- 	 / const
- 第十四章 重载运算与类型转换
	- 基本概念
		- 分类
			- 可重载运算符
				- 按参数个数分类
					- 一元运算符
					- 二元运算符
					- 有4个运算符既是一元又是二元 + - * & 看参数判断
				- 按是否成员函数分类
					- 成员函数
						- 有4个运算符必须是成员函数 = [] () ->  
					- 非成员函数
						- 输入输出运算符必须是非成员函数 （否则使用上就变成data << cout;）
			- 不可重载运算符
				- 有4个符号不能被重载 :: .* . ?:
				- 通常不应该重载 逗号 取地址 逻辑 逻辑或运算符
		- 其他
			- 如果一个运算符函数是成员函数 this绑到左值
			- 一个运算符函数或者是类的成员 或者至少含有一个类类型的参数 which means内置类型的运算符是不能重载的
			- 只能重载 不能发明
			- 重载函数的优先级与内置类型运算符的优先级一致
			- 使用也与内置类型运算符一致
				- 赋值和复合赋值运算符
					- 赋值 			返回左值引用
					- 复合赋值 		先+ 再=
		- 直接调用一个重载的运算符函数
			- 非成员函数
				- v1 + v2 等价于 operator+(v1,v2)
			- 成员函数
				- v1 += v2 等价于 v1.operator+=(v2)
		- 选择作为成员函数or非成员函数
			- 有的运算符必须是成员函数
			- 其他时候非成员函数更好
			- 原则：
				- 处理单一类 类内操作
					- = [] () -> 4个运算符必须是成员函数
					- 复合赋值运算符一般来说是成员函数 但不是必须
					- 改变对象状态 与这个类密切相关的运算符 比如 递增递减 解引用 一般是成员函数
				- 处理混合类 跨类操作
					- 具有对称性的可转换任意一端的运算对象 如算数 相等性 关系 位运算符等 一般是非成员函数
	- 输入和输出运算符
		- 输出运算符尽量减少格式化操作 格式化的部分留给使用者
		- 非成员函数又需要读取类的私有数据成员 就需要友元函数声明
		- 输入错误
			- 当流含有错误类型的数据时 读取操作可能失败
			- 当读取操作达到文件末尾 或遇到输入流的其他错误时也会失败
			- 定义流的读取格式 输入完成后再去判断是否是有效输入 无效输入给予默认值
	- 算术和关系运算符
		- 形参一般是常量引用
		- += 实现 + 的好处是避免创建了一个临时对象 提高效率
	- 赋值运算符
	- 下标运算符
	- 递增和递减运算符
		- 前置运算符
			- 后置运算符
				- 记录原值
				- 调用前置运算符
				- 返回原值
	- 成员访问运算符
	- 函数调用运算符
		- lambda是函数对象
			- lambda可以用类和()函数调用运算符替换
			- 来自自己：
				- 报错
					- 头文件分开引入的话没问题 如果都写在main文件里 谓词类需要写在调用类前面 否则报错undeclared identifier
		- 标准库定义的函数对象
			- eg. less<int> less<string> less<string*>之类的
			- 是标准库可用于替换lambda谓词的模板
			- 使用时需结合bind使用
				- bind(less<int>(),_1,i)
		- 可调用对象和function
			- 调用形式 return type(agrT1,argT2)
			- 不同类可能具有相同的调用形式
			- 标准库function类型
				- 解决lambda类型和普通类具有同样调用形式但在map中存储调用形式时类型不匹配的情况
				- 操作
					- function<T> f; 						T是一个调用形式 比如 int(int,int)
					- function<T> f(nullptr); 				显式构造一个空function
					- function<T> f(obj); 					在function中存储可调用对象obj的副本
					- if (f) 								当f含有一个可调用对象时为真
					- f(args)								调用f中的对象 参数是args
				- 重载函数与function
					- 不能直接把有重载函数的名字存入function类的对象中
					- 放指针 根据map或使用时要求的调用形式会调用到正确的那个重载函数
					- 或者放lambda
 	- 重载 类型转换与运算符
 		- 类型转换运算符
	 		- 语法 operator type() const {return some_val;}; 
	 		- 实践中 类很少提供类型转换运算符
	 			- 在大多数情况下 如果类型转换自动发生 用户会感到很意外 而不是感觉受到了帮助
	 			- 例外：bool类型转换
	 		- 因此大多数时候最好使用显式的类型转换运算符
	 			- 语法：加explicit explicit operator type() const {return some_val;};
	 				用户使用时配合强转 static_cast<T>(v)
	 			- 例外： 如果表达式被用作条件判断 编译器会自动使用强转
	 				- if while do语句的条件判断
	 				- for 语句的条件表达式
	 				- 逻辑与或非运算符
	 				- 三元条件运算符
			- 转为bool
				- eg. while cin >> s 如果cin的条件是good 编译器隐式执行强转
		- 避免有二义性的类型转换
			-  实参匹配和相同的类型转换
				- A类的构造使用了B类 同时A类定义了B类的转换函数 就局有二义性
					- 且无法通过强转解决 强转也具有二义性
					- 只能显示调用
			- 二义性与转换目标为内置类型的多重类型转换
				- 如果一个类包含多个类型转换 确保在类类型和目标类型之间只存在唯一一种转换方式 否则会有二义性
				- 多重转换的两种情况
					- A定义了B类型转换函数 B也定义了A类型的转换函数
					- 定义了多个算数类型类型转换 但其实内置算数类型自己也会转
				- 对编译器来说 从内置算数类型转 会比从自定义类型转更优先
			- 经验
				- 除了bool不要随便定义类型转换 一定要的话
					- A定义了B类型转换函数 B就不要再定义了(何况A还可以采用B传参构造的方式 不一定要用到类型转换)
					- 定义了一个内置算数类型的类型转换 就不要再定义别的了
						- 注意非成员函数的运算符重载和类型转换函数二义性冲突的情况 详细如下
		- 函数匹配与重载运算符
			- 调用一个命名函数时 具有该名字的成员函数和非成员函数不会彼此重载 因为调用成员函数和非成员函数的语法不同
			- 在表达式中使用重载运算符时 无法判断使用的是成员函数还是非成员函数 两者都要考虑
- 第十五章 面向对象程序设计
	- oop概述
		- 基于三个概念：数据抽象（第七章） 继承和动态绑定（本章）
		- 继承和动态绑定对程序编写的影响：
			- 编写时 更容易定义与已有类 类似但不完全相同的类
			- 使用时 在一定程度上可以忽略他们的区别
		- 派生类base class - 继承inheritance - 基类 derived class
			- 基类 		负责  	所有类共同拥有的成员
			- 派生类  	负责 	每个类各自持有的成员
			- 虚函数 virtual function
			- 类派生列表
				- 语法
					- class derived_class_name : public/private base_class_name {};
			- 动态绑定 dynamic binding
				- 运行时绑定 run-time binding
				- 在C++中 使用基类的引用（或指针）调用一个虚函数时将发生动态绑定
	- 定义基类和派生类
		- 基类通常应该定义一个虚析构函数 即使该函数不执行任何操作
		- 成员函数和继承
			- 基类需要区分两种成员
				- 希望派生类 进行覆盖 的函数 即 虚函数 	virtual 任何除构造函数外的非静态函数都可以是虚函数
				- 希望派生类 直接继承 的函数 即 非虚函数 	non-virtual
		- 访问控制与继承
			- 派生类除了能访问public成员 还能访问protected成员
		- 定义派生类
			- 派生类列表 语法如上
			- 派生类中的虚函数
				- 语法
					- 声明的开头 加virtual 不是必须 	定义不用
					- 声明的 const 之后 加 override 	定义不用
			- 派生类对象及派生类向基类的类型转换
				- 派生类到基类的类型转换 derived-to-base
					- 派生类包含基类的数据 所以可以把派生类对象当基类来使用
						- 基类的指针或引用可以绑定到派生类的基类部分上 编译器隐式执行
			- 派生类构造函数
				- 每个类控制它自己的成员初始化过程
					- 尽管派生类对象中含有基类继承而来的成员 但派生类不能直接初始化这些成员 也必须使用基类的构造函数来初始化成员
					- 语法
						- Derived_foo(T a,T b, T c, T d)
							: Base_foo(a,b),private_c(c),private_d(d) {}
						- 如果基类没有(a,b)这样特别指出的话 会用基类的默认构造函数
					- 过程
						- 总得来说：先初始化基类的部分 然后按照声明的顺序依次初始化派生类的成员
							- 先用基类的构造函数初始化基类数据成员
							- {}空函数体结束后 基类对象初始化完成
							- 通过派生类构造函数直接定义派生类自有的数据成员
							- 派生类对象完成初始化
			- 派生类使用基类的成员
				- 派生类可以使用基类的public和protected成员
				- 派生类的作用域嵌套在基类的作用域类 因此使用上和使用基类没有什么不同
			- 继承和静态成员
				- 如果基类定义了一个静态成员 在整个继承体系中仅存在该成员的唯一定义
				- 静态成员遵循访问控制规则 基类定义其静态成员是public和protected的 那派生类可以访问
			- 派生类的声明
				- 声明时无需写派生类列表 :public Base
					- 声明语句的目的：让程序知道这个名字的存在 以及这个名字代表一个什么类型 类 函数 还是变量等
					- 派生类列表对声明没有用
					- 派生类列表和类的定义体一起出现
			- 被用作基类的类
				- 直接基类 direct base
				- 间接基类 indirect base
				- 每个类都会继承直接基类的所有成员
					对一个最终类来说 它包含直接基类的子对象和每个间接基类的子对象
			- 防止继承的发生
				- 语法
					- final 紧跟在类名后
		- 类型转换与继承
			- 存在继承关系的类型之间的转换规则
				- 从派生类向基类的转换只对指针或引用类型有效
				- 基类向派生类不存在隐式类型转换
				- 和任何其他成员一样 派生类向基类的转换也可能由于访问受限而不得行
			- 智能指针也像内置指针一样 支持派生类向基类的类型转换 可以将一个派生类对象的指针存储在一个基类的智能指针内
			- 静态类型和动态类型
				- 静态类型是指针或引用型 动态类型看实参到底是什么类型 是动态绑定得到的实参类型
				- 如果表达式既不是引用也不是指针 它的动态类型永远和静态类型一致
			- 不存在从基类向派生类的隐式类型转换
				- 之所以存在派生类向基类的类型转换 是因为 每个派生类对象都包含一个基类部分 基类的引用或指针可以绑定到该基类上
				- 一个基类的对象可能是派生类的一部分 也可能不是（通常不是） 所以不存在这种自动转换
				- 即使一个基类指针指向一个派生类对象 也不能把这个指针赋值给派生类指针
			- 在对象之间不存在类型转换（指指针和实体对象那个实体对象）
				- 派生类向基类的自动转型只对指针或引用类型有效
				- 派生类类型和基类类型之间不存在这样的转换
					- 回顾派生类调用构造函数初始化的过程中 先调用了基类的构造函数处理基类数据成员
						由于每个类都控制自己的成员初始化过程 当给基类构造函数传递一个派生类对象时 基类只能处理自己的数据成员 
						同理赋值也一样
					- 实际发生的是
						- 当用一个派生类对象向一个基类对象初始化或赋值时 只有该派生类对象中的基类部分会被拷贝 移动 或赋值
							派生类对象会被忽略掉
	- 虚函数
		- 来自侯捷
			- non-virtual
				- 你不希望重新定义它（即使派生类写了这个功能也会用基类的同名功能去实现 派生类功能白写）
			- virtual
				- 你希望派生类最好能重新定义 但是你给了基类的一个默认定义 如果派生类没有自己的实现 可以编译成功 并调用基类的默认实现 比如基类是空函数时 用不到这个功能的派生类不实现是不会报错的 那些需要用到的派生类就覆写（派生类自己可以自己实现更精细的想法）
			- pure virtual
				- 你一定要派生类重新定义这个函数 因为基类没有实现 返回值为0（基类告诉你流程上这里需要这样的功能 具体怎么实现是派生类的责任）
		- 每一个虚函数都必须有定义
			- 因为编译器不知道动态绑定的过程中 到底会调用到哪一个虚函数 所以都要有
			- 再来理解下侯捷的说法
				- 所以基类实现了虚函数 派生类没有实现时 用基类的
					基类没有实现虚函数时 派生类自己一定要实现
		- 对虚函数的调用可能在运行时才被解析
			- oop的核心思想 多态 polymorphism 多种形式 其原因就在于 引用或指针的静态类型和动态类型不同 必须是引用或指针哦
		- 派生类中的虚函数
			- virtual在派生类的声明中不是必须的 因为一旦某个函数被声明成虚函数 在所有派生类中它都是虚函数
			- 一个派生类的虚函数 其形参 		必须和基类的形参完全一致
			- 一个派生类的虚函数 其返回类型 	必须和基类的形参完全一致
				- 例外：返回指针或引用时该规则无效 可类型转换的指针或引用即可
		- final和override
			- 如果函数名相同 形参列表不同 则编译器认为 这是派生类独有的函数 和基类无关
			- 但这种情况很可能不是我们想要的 而调试这种错误非常困难
			- 引入override 显式告诉编译器检查 这是一个虚函数 如果形参是我搞错了你告诉我
			- final和override有必要的话可以同时写的
				- 回顾下 final防止派生类继承函数
				- override告诉编译器检查虚函数的形参和返回类型是不是对
		- 虚函数与默认实参
			- 通过基类的引用或指针调用虚函数 使用的是基类的默认实参
			- 如果虚函数使用默认实参 确保基类和派生类的默认实参一致 否则确保你知道上一条
		- 回避虚函数机制
			- 回避动态绑定 指定某个特定的虚函数版本
			- 语法
				- double undiscounted = baseP->Quote::net_price(42);
			- 一般是派生类调用基类版本的虚函数执行共有操作 再用派生类自己的虚函数执行自己的特殊操作
			- 作用域运算符不使用的话 会导致无限递归派生类虚函数
	- 抽象基类
		- 纯虚函数 pure virtual
			- 语法
				- 声明语句最后 比如 const 后 加 = 0;
		- 含有纯虚函数的类是抽象基类
			- 抽象基类负责定义接口 派生类可以覆盖该接口
			- 我们不能直接创建一个抽象基类的对象
		- 重构 refactoring
			- 在基类和派生类之间加一个抽象基类 就是 重构
			- 重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中
	- 访问控制与继承
		- 类的设计
			- 不考虑继承的话 类的用户可以分为两种 一种是类的使用者 一种是类的实现者
				分别可以对应public 和 private成员
			- 考虑继承的话 新增了第三类用户 即派生类
				派生类对应protected 同时派生类也有自己的使用者和实现者 分别对应public 和 private
		- protected
			- 派生类和友元可以访问
			- 派生类和友元只能通过派生类对象来访问基类的受保护成员
				- 一个基类 一个派生类 一个派生类的友元
					友元形参是 	派生类 	的引用 	可以 	访问基类的protected成员（派生类及其友元可以访问基类protected成员）
					友元形参是 	基类 	的引用 	不能 	访问基类的protected成员（基类不能访问自己的protected成员）
					- 如果可以的话 那一个类的非友元函数仍然可以改变这个类的数据
						protected这个语法就形同虚设
		- 公有 私有和受保护继承
			- 不管派生类是public还是private继承一个基类 都可以访问其protected成员
			- 但是继承自派生类D的派生类DD 
				如果继承自的派生类D是public继承基类 那DD可以访问基类的protected成员
				如果继承自的派生类D是private继承基类 那DD不可以访问基类的protected成员(和其他所有基类成员)
		- 派生类向基类转换的可访问性
			- 只有当D public 继承B 用户代码才能 从D转B
			- 不论D何种继承B D的成员函数和友元都能使用派生类向基类的转换
			- 如果D继承B的方式是 public 或者 protected 那D的派生类的成员和友元可以使用D向B的类型转换
		- 友元与继承
			- 友元关系不能传递也不能继承 每个类负责控制各自成员的访问权限
			- 基类的友元不是派生类的友元
		- 改变个别成员的可访问性
			- 派生类私有继承自基类时 可以通过using声明 把基类中需要使用的成员重新放在派生类的public或protected区里
		- 默认的继承保护级别
			- 类似class和struct的区别 
				使用class定义的派生类默认是私有继承 
				使用struct定义的派生类默认是公有继承
				可以省略继承语法中的public和private 但是显示声明总是让继承关系更清晰
	- 继承中的类作用域
		- 每个类定义自己的作用域 当存在继承关系时 派生类的作用域嵌套在其基类的作用域之内
			如果一个名字在派生类作用域内无法解析 编译器会在外层的基类作用域中寻找名字的定义
			所以派生类向基类转型后 寻找名字的作用域就会从基类作用域开始往外找 虽然对象中仍有派生类的一些成员 但其转型后就不可见了
		- 名字和冲突继承
			- 派生类的成员将隐藏同名的基类成员
			- 可以使用作用域运算符来使用一个被隐藏的基类成员
			- 然而 除了覆盖继承而来的虚函数 派生类最好不要重用其他定义在基类中的名字
		- 函数调用的解析过程
			- p->mem() or obg.mem()
			1. 首先确定p的静态类型
			2. 名字查找 
				去p的静态类型对应的类中查找mem() 找不到就往外扩找基类 直到继承链的顶端 还找不到的话 编译器会报错
			3. 类型检查 
				找到mem()后 常规类型检查 形参列表和返回值等 确认调用是否合法
			4. 假设调用合法 编译器将根据调用的是否是虚函数而产生不同的代码
			注1：名字查找先于类型检查 如果派生类和基类名字冲突 直接调用时即使和基类参数列表匹配 也会由于在名字查找时被隐藏而无法调用
			注2：这也是虚函数要求派生类和基类有相同的形参列表的原因 否则在没有override的情况下会创造一个同名无关函数 隐藏基类的同名虚函数
				但只是对自己隐藏 而且也保留了覆写的权利 派生类的派生类也还是可以继续覆写基类的虚函数的
		- 虚函数和作用域
			- 见上注2
		- 覆盖重载的函数
			- using
	- 构造函数与拷贝控制
		- 虚析构函数
			- 回顾之前的三五法则 需要析构函数的类也需要拷贝构造和拷贝赋值 但 如果一个类是基类 它总是需要一个虚析构函数 它也不需要拷贝或赋值
		- 合成拷贝控制与继承
			- 派生类会一路调用间接基类和直接基类的合成或自己写的构造函数合成构造
			- 由于虚析构函数函数体为空 不会有合成的移动操作 只会有合成的拷贝
			- 删除的情况
				- 查表型
			- 移动操作与继承
				- 如果派生类可能会用到移动操作 那基类需要显示=default定义一个合成移动操作
					一旦基类显式定义一个移动操作 它也得显式定义一个拷贝操作 回顾三五法则
		- 派生类的拷贝控制成员
			- 介绍
				- 回顾其初始化过程 除了普通类需要初始化自己的成员 还要初始化基类成员
				- 析构函数只需要销毁自己负责分配的资源即可
			- 定义派生类的拷贝或移动构造函数
				- 显式调用基类的拷贝或构造函数 否则调用到基类的默认构造可能会变成
					派生类的基类部分 成员是默认初始值 而派生类的值从其他对象拷贝而来（拷了派生类没拷基类？）
			- 派生类赋值运算符
				- 通过作用域运算符 显式为其基类部分赋值
			- 派生类析构函数
				- 回顾 析构函数只需要销毁自己负责分配的资源
				- 析构的顺序与构造的顺序相反 先派生后基类
			- 在构造函数和析构函数中调用虚函数
				- 查表型
		- 继承的构造函数
			- 派生类不能直接继承基类的构造函数 如果没有定义 编译器会采用合成版本
			- using语句 令编译器生成一个和基类形参列表相同的构造函数 派生类的其他数据成员将默认初始化
			- 特点
				- 一个构造函数使用using语句不会改变其访问级别
				- 一个using语句不能声明explicit或constexpr 
					但如果基类的构造函数是explicit或constexpr 使用using的构造函数也有相应特性
				- 当一个基类含有默认实参
					默认实参不会被继承 派生类将会获得多个构造函数
					比如基类有2个形参 第二个有默认值 派生类会获得两个构造函数
					一个是2个形参 第二个无默认值
					一个是仅含第一个形参
	- 容器与继承
		- 容器内元素是相同的 
			所以通常不能把具有继承关系的多种类型的对象直接存放在容器中 派生类放在用于存放基类的容器中 派生类的部分会被抹掉 object slicing
		- 在容器中存放（智能）指针而非对象
		- 举例
			- 来自自己：
				- 之前就觉得print_total的参数需要手动指定同一本书有多少本 这不太合理 
					但是通过一个multiset类存放多个对象的智能指针 
					再封装一个total_receipt函数 用multiset自带的count来统计一本书有多少本 就很妙
				- 派生类的(智能)指针在放到基类(智能)指针容器时保留了派生类的类型 在调用虚函数时可以动态绑定到派生类
					- 之前我很疑惑为什么指针大小都是一样的 但容器存指针还需要指定类型
						- 首先要考虑到 容器元素是唯一的
						- 猜测类似函数调用的过程会有各种检查 容器放元素进去也有各种检查
						- 不同类型的指针无法通过编译
						- 派生类指针由于可以向基类转型 派生类包含一个基类部分 可以通过编译
						- 容器添加元素进行拷贝 对（智能）指针来说 底层数据还是不变的 没有办法对底层数据做object slicing
	- 文本查询系统再探
		- 在原本精确匹配的基础上 加上与或非匹配
		- 来自自己：
			- 15.39 实现Query类和派生类
				- 回顾之前实现的文本查询Text_query类和Query_reult类是什么
					- Text_query存放读到的数据和所有已经分类好的数据以供查询
						- 存的数据 按行把数据存下来 存到一个容器中
							- 容器元素  使用过string 	也使用过自己设计的类My_string(使用allocator<char>)
							- 容器 	   使用过vector	也使用过自己设计的类Str_vec(存放3根指针 按照vector的特性实现内存分配)
							- 存的方式 试过直接存容器 也试过存shared_ptr型容器
						- 分类的数据是一个map映射 key是查询的单词 value是一个set 元素是单词出现的行数
							- 存的方式 试过直接存容器 也试过存shared_ptr型容器
					- Query_result是一个查询结果 保存map映射表的一个元素 也要可以访问到Text_query读到的数据 打印查询结果
				- 考虑新增需求需要修改什么
					- 原先的打印结果中 单词改变了 加入了不同的query类型 同样的查询单词 由于query类型不同 返回行数也有相应改变
					- 为了体现不同query类型 以及不同类型行为的不同 需要创造不同的query类
						- 考虑query类之间的关系
							- 所有query类型不是彼此继承的关系 意味着很可能可以收到一个抽象基类中 再去继承
								- 抽象基类需要什么功能呢？
									- 所有query都需要的功能
										- 改造单词 体现出单词及query类型 rep() 封装word
										- 构造不同query类型对应的行数返回Query_result eval() 构造query_result
							- 考虑是否需要接口类
								- 用户不会知道也不该知道具体的query类到底是什么 用户调用接口即可 也不用直面原先的query_result类
								- 因此接口类query是必要的
									- 回顾 引用或指针的静态类型和动态类型不同
									- query类应该保存query抽象基类的指针（智能指针）
									- 重载抽象基类虚函数时返回指针派生类对虚函数的实现
							- 所有query类型是否全部都平行呢？还是有一定层级关系？
								- 根据使用需求来说 原先的单词精确查询和not查询需要一个运算对象 and和or需要两个运算对象
								- 一个运算对象
									- word_query
										- 为了体系清晰 之前的精确查询可以封装在一个继承了抽象基类的query类中
									- not_query
										- 考虑如何构造
											- 只有用到操作符重载时需要返回not_query对象的指针 也就是此时才需要构造函数
											- 此时参数是query类型 所以用query类型来构造
										- 考虑如何重载虚函数
											- rep()
												- 改写word
											- eval(const Text_query&)
												- 这里我使用了一个for循环 循环总行数的size() 构造单词出现的总行数
													- 再用find()算法判断 当前行是否在出现行中 未出现就存到一个新的容器中
												- 使用rep()和新容器构造query_result返回
								- 两个运算对象
									- 考虑再加一层抽象基类
										- 考虑抽象基类可以有什么共有函数 
											- rep()可以放在抽象基类里
									- 如何构造
										- 同样的 只有操作符重载返回不同query类型的指针时 需要构造函数
										- 参数是两个query常值引用 而且重载虚函数时不可避免地需要用到两个query
										- 因此存两个query
										- rep() 需要体现query类型 因此再保存一个string 表示query类型
									- 考虑如何重载虚函数
										- rep()
											- 改写word
										- and_query
											- eval(const Text_query&)
												- set_intersection算法求两个query所含的两个单词所在行的并集
													- set_intersection的第五个参数要求插入位置 
													如果容器是空的需要用一个inserter(c,cp)
												- 使用rep()和新容器构造query_result返回
										- or_query
											- eval(const Text_query&)
												- 先用其中一个query所在行的首尾指针创造一个容器
												- 再添加第二个query所在行的元素（添加地址和另一个query所在行的首尾指针）
												- 使用rep()和新容器构造query_result返回
										- 实现时需要添加对应的操作符重载的友元函数和获取私有数据成员的友元类
							- 接口类实现
								- 考虑如何构造
									- 从使用角度看 query类默认应该是精确查询 在运算符重载的情况下 返回指定query类型
										- 因此query类应该有两个构造函数
											- 一个是接受string 构造word_query 存指针
											- 一个私有构造函数 用于把运算符重载时返回的指定类型query 转成query类型
			- 15.41 Query类的智能指针改为内置指针 复习
				- big three中内置指针需要如何替代智能指针 写法比较固定
					- 理解 --*ref_count
			- 15.42.2 引入历史查询系统 在原来代码的基础上修改了
				- 先考虑调用方式 
					- 历史查询应该是属于text_query类的数据成员（has-a）
						- 考虑封装一个History类作为其成员
						- 考虑它应该是static属性的 只需要一份就可以 记得类外声明
						- 考虑每次查询后需要自动保存到历史查询结果中 这在接口类Query中统一修改最方便
					- text_query t 
						- t.history()
						- t.query(history_query_num)
				- 修改原先代码中
					- Text_query类
						- 增加text_query相应数据成员
							- t.history() 可以封装调用History类的函数
							- t.query(history_query_num) 是之前query()函数的重载 也放在之前接口类Query的的cpp文件中
					- History类
						- 保存一个元素为Query_base*的set 存的是Query类
						- 为了使用合成的拷贝赋值析构和移动 使用shared_ptr来存
						- 根据接口使用 创建必要的函数
					- Query类
						- eval()函数增加自动保存query类对象到History类中
					- 需要访问私有数据成员的类 加上友元
					- 有任何问题F5断点调试